{
  "version": 3,
  "sources": ["../src/ast.ts", "../src/codegen.ts", "../src/token.ts", "../src/lexer.ts", "../src/tokenbuffer.ts", "../src/errors.ts", "../src/type.ts", "../src/parser/exprparser.ts", "../src/parser/decparser.ts", "../src/parser/assignparser.ts", "../src/parser/bodyparser.ts", "../src/parser/ifparser.ts", "../src/parser/whileparser.ts", "../src/parser/stmtparser.ts", "../src/parser.ts", "../src/typecheck/variable.ts", "../src/typecheck/scope.ts", "../src/typecheck/exprchecker.ts", "../src/typecheck/typechecker.ts", "../web/editor/l.ts", "../web/editor/editor.ts", "../web/index.ts"],
  "sourcesContent": ["import {Token, Kind} from \"./token.ts\";\r\nimport { Type } from \"./type.ts\";\r\n\r\nexport interface AstNode {\r\n    readonly start: Token,\r\n}\r\n\r\n//Statements\r\n//=============================================\r\nexport type Statement = Body | IfStatement | WhileStatement\r\n    | MacroDeclaration | MacroCall | Declaration | Assignment;\r\n\r\nexport interface IStatement extends AstNode {}\r\n\r\nexport class Body implements IStatement {\r\n    constructor(private open: Token, public content: Statement[]) {}\r\n\r\n    get start(): Token {\r\n        return this.open;\r\n    }\r\n\r\n    toString() {\r\n      return `Body {\\n${this.content.join(\"\\n\")}\\n}`;\r\n    }\r\n}\r\n\r\nexport class IfStatement implements IStatement {\r\n    constructor(\r\n        public condition: Expression,\r\n        public body: Body,\r\n        public child: Body | IfStatement | undefined\r\n    ) {\r\n    }\r\n    get start(): Token {\r\n        return this.condition.start;\r\n    }\r\n\r\n    toString() {\r\n      return `If(\\n\\t${this.condition} \\n\\t${this.body} else \\n\\t${this.child ?? \"nothing\"})`;\r\n    }\r\n  }\r\n\r\nexport class WhileStatement implements IStatement {\r\n    constructor(public condition: Expression, public body: Body) {}\r\n\r\n    get start(): Token {\r\n        return this.condition.start;\r\n    }\r\n\r\n    toString() {\r\n      return `While(\\n\\t${this.condition} \\n\\t${this.body})`;\r\n    }\r\n  }\r\n  \r\nexport class MacroDeclaration implements IStatement {\r\n    constructor(\r\n        public name: Identifier,\r\n        public args: Expression[],\r\n        public body: Body\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `MacroDecl(${this.name} ${this.args.join(\", \")};\\n${this.body})`;\r\n    }\r\n  }\r\n  \r\nexport class MacroCall implements IStatement {\r\n    constructor(public name: Identifier, public args: IExpression[]) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `MacroCall(${this.name} ${this.args.join(\", \")}})`;\r\n    }\r\n}\r\n\r\nexport class Declaration implements IStatement {\r\n    constructor(\r\n        public vartype: VarType,\r\n        public name: Identifier,\r\n        public expr?: Expression\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.vartype.start;\r\n    }\r\n\r\n    toString() {\r\n      return `Declaration(${this.vartype} ${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class Assignment implements IStatement {\r\n    constructor(public name: Identifier, public expr: Expression) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `Assignment(${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class VarType {\r\n    constructor(public type: Type, public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `VarType(${this.type} ${this.token})`;\r\n    }\r\n}\r\n\r\n//Expressions\r\n//=============================================\r\nexport type Expression = Number | Identifier | BinaryOp | ArrayLiteral | ArrayAccess;\r\nexport interface IExpression extends AstNode {}\r\n\r\nexport class Number implements IExpression {\r\n    constructor(public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `Number(${this.token})`\r\n    }\r\n}\r\n\r\nexport class Identifier implements IExpression {\r\n    constructor(public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `Identifier(${this.token})`;\r\n    }\r\n}\r\n\r\nexport class BinaryOp implements IExpression {\r\n    constructor(\r\n        public expr1: Expression,\r\n        public op: Token,\r\n        public expr2: Expression\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.expr1.start;\r\n    }\r\n\r\n    toString() {\r\n      return `BinOp(${this.expr1} ${this.op} ${this.expr2})`;\r\n    }\r\n}\r\n\r\nexport class ArrayLiteral implements IExpression {\r\n    constructor(private open: Token, public items: Expression[]) {}\r\n\r\n    get start(): Token {\r\n        return this.open;\r\n    }\r\n\r\n    toString() {\r\n      return `ArrayLit(${this.items.join(\", \")})`;\r\n    }\r\n  }\r\n  \r\nexport class ArrayAccess implements IExpression {\r\n    constructor(public array: Identifier, public index: Expression) {}\r\n\r\n    get start(): Token {\r\n        return this.array.start;\r\n    }\r\n\r\n    toString() {\r\n      return `ArrayAccess(${this.array} ${this.index})`;\r\n    }\r\n}", "import * as ast from \"./ast.ts\";\r\n\r\nexport class Asm {\r\n    instrs: string[];\r\n    constructor(readonly source: ast.AstNode) {\r\n        this.instrs = [];\r\n    }\r\n    toString() {\r\n        return this.instrs.join(\"\\n\");\r\n    }\r\n    putLI(dest: number, value: number) {\r\n        this.instrs.push(\"IMM R\" + dest + \" \" + value);\r\n    }\r\n    putLOAD(reg: number, addr: number) {\r\n        this.instrs.push(\"LOD R\" + reg + \" #\" + addr);\r\n    }\r\n    putSTORE(addr: number, reg: number) {\r\n        this.instrs.push(\"STR #\" + addr + \" R\" + reg);\r\n    }\r\n    putADD(dest: number, srcA: number, srcB: number) {\r\n        this.instrs.push(\"ADD R\" + dest + \" R\" + srcA + \" R\" + srcB);\r\n    }\r\n    putSUB(dest: number, srcA: number, srcB: number) {\r\n        this.instrs.push(\"SUB R\" + dest + \" R\" + srcA + \" R\" + srcB);\r\n    }\r\n    putMULT(dest: number, srcA: number, srcB: number) {\r\n        this.instrs.push(\"MULT R\" + dest + \" R\" + srcA + \" R\" + srcB);\r\n    }\r\n    putDIV(dest: number, srcA: number, srcB: number) {\r\n        this.instrs.push(\"DIV R\" + dest + \" R\" + srcA + \" R\" + srcB);\r\n    }\r\n    putBRANCH(instr: string, label: string, left: number, right: number) {\r\n        this.instrs.push(instr + \" \" + label + \" R\" + left + \" R\" + right);\r\n    }\r\n    putLABEL(label: string) {\r\n        this.instrs.push(label);\r\n    }\r\n    putJMP(label: string) {\r\n        this.instrs.push(\"JMP \" + label);\r\n    }\r\n}\r\n\r\nexport class CodeGeneration {\r\n    allocator: Allocator;\r\n    label: number;\r\n    asmList: Asm[];\r\n\r\n    constructor(maxRegisters: number) {\r\n        this.asmList = [];\r\n        this.allocator = new Allocator(maxRegisters);\r\n        this.label = 0;\r\n    }\r\n\r\n    gen(astNodes: ast.Statement[]) : Asm[]{\r\n        for(const astNode of astNodes) {\r\n            this.genStatement(astNode);\r\n        }\r\n        return this.asmList;\r\n    }\r\n\r\n    genStatement(statement: ast.Statement) {\r\n        const asm: Asm = new Asm(statement);\r\n        if(statement instanceof ast.Declaration) {\r\n            this.genDeclaration(asm, statement);\r\n            this.asmList.push(asm);\r\n        }\r\n        else if(statement instanceof ast.Assignment) {\r\n            this.genAssignment(asm, statement);\r\n            this.asmList.push(asm);\r\n        }\r\n        else if(statement instanceof ast.IfStatement) {\r\n            this.genIfStatement(statement, undefined);\r\n        }\r\n        else if(statement instanceof ast.WhileStatement) {\r\n            this.genWhileStatement(asm, statement);\r\n            this.asmList.push(asm);\r\n        }\r\n        else {\r\n            //error - No code gen for this statement\r\n            return;\r\n        }\r\n    }\r\n\r\n    genBody(body: ast.Body) {\r\n        for(const statement of body.content) {\r\n            this.genStatement(statement);\r\n        }\r\n    }\r\n\r\n    genWhileStatement(asm: Asm, whileStatement: ast.WhileStatement) {\r\n        const endLabel: string = this.genLabel();\r\n        const startLabel: string = this.genLabel();\r\n        const startAsm: Asm = new Asm(whileStatement.condition);\r\n        startAsm.putLABEL(startLabel);\r\n        this.genCondition(startAsm, whileStatement.condition, endLabel);\r\n        this.asmList.push(startAsm);\r\n        this.genBody(whileStatement.body);\r\n        asm.putJMP(startLabel);\r\n        asm.putLABEL(endLabel);\r\n    }\r\n\r\n    genIfStatement(ifStatement: ast.IfStatement, endLabel: undefined | string) {\r\n        let label = this.genLabel();\r\n        if(ifStatement.child != undefined && endLabel === undefined) {\r\n            endLabel = this.genLabel();\r\n        }\r\n        if(ifStatement.child === undefined && endLabel != undefined) {\r\n            label = endLabel;\r\n        }\r\n        const condAsm: Asm = new Asm(ifStatement.condition);\r\n        this.genCondition(condAsm, ifStatement.condition, label)\r\n        this.asmList.push(condAsm);\r\n        this.genBody(ifStatement.body);\r\n        const asm: Asm = new Asm(ifStatement);\r\n        if(ifStatement.child != undefined && endLabel != undefined) {\r\n            asm.putJMP(endLabel);\r\n        }\r\n        asm.putLABEL(label);\r\n        this.asmList.push(asm);\r\n\r\n        if(ifStatement.child instanceof ast.IfStatement) {\r\n            this.genIfStatement(ifStatement.child, endLabel);\r\n        }\r\n        else if(ifStatement.child instanceof ast.Body) {\r\n            this.genBody(ifStatement.child);\r\n            const elseAsm: Asm = new Asm(ifStatement.child);\r\n            if(endLabel != undefined) {\r\n                elseAsm.putLABEL(endLabel);\r\n                this.asmList.push(elseAsm);\r\n            }\r\n            else {\r\n                console.log(\"ERROR\");\r\n            }\r\n        }\r\n    }\r\n\r\n    genCondition(asm: Asm, condition: ast.Expression, endLabel: string) {\r\n        if(!(condition instanceof ast.BinaryOp)) {\r\n            //generate an error here probably\r\n            return asm;\r\n        }\r\n        const reg1: number = this.genExpression(asm, condition.expr1);\r\n        const reg2: number = this.genExpression(asm, condition.expr2);\r\n        const op: string = condition.op.value\r\n        switch(op) {\r\n            case \">\": {\r\n                asm.putBRANCH(\"BLE\", endLabel, reg1, reg2); break;\r\n            }\r\n            case \">=\": {\r\n                asm.putBRANCH(\"BRL\", endLabel, reg1, reg2); break;\r\n            }\r\n            case \"<\": {\r\n                asm.putBRANCH(\"BGE\", endLabel, reg1, reg2); break;\r\n            }\r\n            case \"<=\": {\r\n                asm.putBRANCH(\"BRG\", endLabel, reg1, reg2); break;\r\n            }\r\n            case \"==\": {\r\n                asm.putBRANCH(\"BNE\", endLabel, reg1, reg2); break;\r\n            }\r\n            case \"!=\": {\r\n                asm.putBRANCH(\"BRE\", endLabel, reg1, reg2); break;\r\n            }\r\n            default: {\r\n                //Generate error here, invalid condition op\r\n            }\r\n        }\r\n        this.allocator.setFreeRegister(reg1);\r\n        this.allocator.setFreeRegister(reg2);\r\n        return asm;\r\n    }\r\n\r\n    genLabel() : string{\r\n        this.label++;\r\n        return \".LABEL_\" + this.label;\r\n    }\r\n\r\n    genDeclaration(asm: Asm, dec: ast.Declaration) {\r\n        const varType: ast.VarType = dec.vartype;\r\n        const varName: string = dec.name.token.value;\r\n        const addr: number = this.allocator.addVariable(varName);\r\n        if(dec.expr) {\r\n            const reg: number = this.genExpression(asm, dec.expr);\r\n            asm.putSTORE(addr, reg)\r\n            this.allocator.setFreeRegister(reg);\r\n        }\r\n    }\r\n\r\n    genAssignment(asm: Asm, assign: ast.Assignment) {\r\n        const varName: string = assign.name.token.value;\r\n        const addr: number = this.allocator.hasVariable(varName);\r\n        if(addr == -1) {\r\n            //generate error, variable was never declared\r\n            return;\r\n        }\r\n        const reg: number = this.genExpression(asm, assign.expr);\r\n        asm.putSTORE(addr, reg);\r\n        this.allocator.setFreeRegister(reg);\r\n    }\r\n\r\n    genExpression(asm: Asm, expr: ast.Expression) : number{\r\n        if(expr instanceof ast.Number) {\r\n            const reg: number = this.allocator.getFreeRegister();\r\n            asm.putLI(reg, parseInt(expr.token.value, 10))\r\n            return reg;\r\n        }\r\n        else if(expr instanceof ast.Identifier) {\r\n            const memAddr: number = this.allocator.addVariable(expr.token.value);\r\n            const reg: number = this.allocator.getFreeRegister();\r\n            asm.putLOAD(reg, memAddr);\r\n            return reg;\r\n        }\r\n        else if(expr instanceof ast.BinaryOp) {\r\n            const reg1: number = this.genExpression(asm, expr.expr1);\r\n            const reg2: number = this.genExpression(asm, expr.expr2);\r\n            switch(expr.op.value) {\r\n                case \"+\": {\r\n                    asm.putADD(reg1, reg1, reg2); break;\r\n                }\r\n                case \"-\": {\r\n                    asm.putSUB(reg1, reg1, reg2); break;\r\n                }\r\n                case \"*\": {\r\n                    asm.putMULT(reg1, reg1, reg2); break;\r\n                }\r\n                case \"/\": {\r\n                    asm.putDIV(reg1, reg1, reg2); break;\r\n                }\r\n                default : {\r\n                    //Generate error - operator token is incorrect\r\n                }\r\n            }\r\n            this.allocator.setFreeRegister(reg2);\r\n            return reg1;\r\n        }\r\n        else {\r\n            //Generate error - the expr token is incorrect\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n\r\nclass Allocator {\r\n    varToMemory: Record<string, number>;\r\n    memory: boolean[];\r\n    registers: boolean[];\r\n\r\n    constructor(maxRegisters: number) {\r\n        this.varToMemory = {};\r\n        this.registers = new Array(maxRegisters);\r\n        this.registers.fill(false);\r\n        this.memory = new Array(512);\r\n        this.memory.fill(false);\r\n    }\r\n\r\n    hasVariable(varName: string) : number {\r\n        if(varName in this.varToMemory) {\r\n            return this.varToMemory[varName];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    addVariable(varName: string) : number {\r\n        if(varName in this.varToMemory) {\r\n            return this.varToMemory[varName];\r\n        }\r\n        const addr: number = this.getFreeMemory();\r\n        this.varToMemory[varName] = addr;\r\n        return addr;\r\n    }\r\n\r\n    getFreeRegister() : number {\r\n        const addr: number = this.registers.indexOf(false);\r\n        this.registers[addr] = true;\r\n        return addr+1;\r\n    }\r\n\r\n    getFreeMemory() : number {\r\n        const addr: number = this.memory.indexOf(false);\r\n        this.memory[addr] = true;\r\n        return addr+1;\r\n    }\r\n\r\n    setFreeRegister(reg: number) {\r\n        reg--;\r\n        this.registers[reg] = false;\r\n    }\r\n\r\n    setFreeMemory(mem: number) {\r\n        mem--;\r\n        this.memory[mem] = false;\r\n    }\r\n}", "export const enum Kind {\r\n  VAR_TYPE = \"VAR_TYPE\",\r\n\r\n  IDENTIFIER = \"IDENTIFIER\",\r\n  NUMBER = \"NUMBER\",\r\n  EQUAL = \"EQUAL\",\r\n  PLUS = \"PLUS\",\r\n  MINUS = \"MINUS\",\r\n  MULT = \"MULT\",\r\n  DIV = \"DIV\",\r\n\r\n  MACROCALL = \"MACROCALL\",\r\n\r\n  COMMENT = \"COMMENT\",\r\n\r\n  OPEN_BRACE = \"OPEN_BRACE\",\r\n  CLOSE_BRACE = \"CLOSE_BRACE\",\r\n  IF = \"IF\",\r\n  ELSE = \"ELSE\",\r\n  ELIF = \"ELIF\",\r\n  WHILE = \"WHILE\",\r\n  MACRO = \"MACRO\",\r\n  COND_G = \"COND_G\",\r\n  COND_L = \"COND_L\",\r\n  COND_E = \"COND_E\",\r\n  COND_LE = \"COND_LE\",\r\n  COND_NE = \"COND_NE\",\r\n  COND_GE = \"COND_GE\",\r\n  COMMA = \"COMMA\",\r\n\r\n  WHITESPACE = \"WHITESPACE\",\r\n\r\n  OPEN_PARAN = \"OPEN_PARAN\",\r\n  CLOSE_PARAN = \"CLOSE_PARAN\",\r\n\r\n  OPEN_SQUARE = \"OPEN_SQUARE\",\r\n  CLOSE_SQUARE = \"CLOSE_SQUARE\",\r\n\r\n  SEMICOLON = \"SEMICOLON\",\r\n\r\n  NONE = \"NONE\",\r\n}\r\n\r\nexport class Token {\r\n  constructor(\r\n    public kind: Kind,\r\n    public value: string,\r\n    public line: string,\r\n    public lineno: number,\r\n    public start: number,\r\n  ){}\r\n\r\n  eq(kind: Kind): boolean {\r\n    return this.kind == kind;\r\n  }\r\n\r\n  toString(): string {\r\n    return `Token(${this.kind} ${this.lineno}:${this.start} ${JSON.stringify(this.value)})`;\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\n\r\nclass Buffer {\r\n    current!: string\r\n    pos!: number\r\n    done!: boolean\r\n    line!: string\r\n    set(line: string) {\r\n        this.current = line[0]\r\n        this.pos = 0\r\n        this.done = false\r\n        this.line = line\r\n    }\r\n\r\n    next(): string {\r\n        this.pos += 1\r\n        if (this.pos < this.line.length) {\r\n            this.current = this.line[this.pos]\r\n        } else {\r\n            this.done = true\r\n            this.current = '\\0'\r\n        }\r\n        return this.current\r\n    }\r\n}\r\n\r\nconst keywords: Record<string, Kind> = {\r\n    \"uint\": Kind.VAR_TYPE,\r\n    \"char\": Kind.VAR_TYPE,\r\n    \"if\": Kind.IF,\r\n    \"else\": Kind.ELSE,\r\n    \"elif\": Kind.ELIF,\r\n    \"while\": Kind.WHILE,\r\n    \"macro\": Kind.MACRO,\r\n}\r\n\r\nconst symbols : Record<string, Kind> = {\r\n    '=': Kind.EQUAL,\r\n    ';': Kind.SEMICOLON,\r\n    '{': Kind.OPEN_BRACE,\r\n    '}': Kind.CLOSE_BRACE,\r\n    '>': Kind.COND_G,\r\n    '<': Kind.COND_L,\r\n    '+': Kind.PLUS,\r\n    '-': Kind.MINUS,\r\n    '*': Kind.MULT,\r\n    '(': Kind.OPEN_PARAN,\r\n    ')': Kind.CLOSE_PARAN,\r\n    ',': Kind.COMMA,\r\n    '/': Kind.DIV,\r\n    '[': Kind.OPEN_SQUARE,\r\n    ']': Kind.CLOSE_SQUARE,\r\n    ' ': Kind.WHITESPACE,\r\n}\r\n\r\nconst double_symbols: Record<string, Kind> = {\r\n    \"==\": Kind.COND_E,\r\n    \">=\": Kind.COND_GE,\r\n    \"<=\": Kind.COND_LE,\r\n    \"!=\": Kind.COND_NE,\r\n    \"//\": Kind.COMMENT,\r\n}\r\n\r\nexport function lex(lines: string[], file_name = \"<eval>\") : Token[]{\r\n    const tokens: Token[] = []\r\n    const buf: Buffer = new Buffer()\r\n    let lineno = 0;\r\n    for (const line of lines) {\r\n        lineno++;\r\n        buf.set(line);\r\n        while (!buf.done) {\r\n            if (isDigit(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let num: string = buf.current;\r\n                while (isDigit(buf.next())) {\r\n                    num += buf.current;\r\n                }\r\n                tokens.push(\r\n                    new Token(Kind.NUMBER, num, line, lineno, start)\r\n                );\r\n            }\r\n            else if(isAlpha(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let word: string = buf.current;\r\n                while (isAlpha(buf.next())) {\r\n                    word += buf.current \r\n                }\r\n                let kind: Kind = Kind.IDENTIFIER;\r\n                if (word in keywords) {\r\n                    kind = keywords[word];\r\n                }\r\n                if (buf.current === \"!\") {\r\n                    buf.next();\r\n                    kind = Kind.MACROCALL;\r\n                }\r\n                tokens.push(\r\n                    new Token(kind, word, line, lineno, start)\r\n                );\r\n            }\r\n            else {\r\n                if (buf.current in symbols) {\r\n                    const start: number = buf.pos;\r\n                    let current: string = buf.current;\r\n                    let symbol_kind: Kind = symbols[current];\r\n                    buf.next();\r\n                    const double_symbol = buf.current + current;\r\n                    if (double_symbol in double_symbols) {\r\n                        symbol_kind = double_symbols[double_symbol];\r\n                        current = double_symbol;\r\n                        buf.next();\r\n                    }\r\n\r\n                    if (symbol_kind === Kind.COMMENT) {\r\n                        buf.done = true;\r\n                        tokens.push(\r\n                            new Token(symbol_kind, line.substring(start), line, lineno, start)\r\n                        );\r\n                    } else {\r\n                        tokens.push(\r\n                            new Token(symbol_kind, current, line, lineno, start)\r\n                        );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    buf.next();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n\r\nfunction isDigit(x: string) {\r\n    return \"0123456789\".includes(x);\r\n}\r\n\r\nfunction isAlpha(x: string) {\r\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(x);\r\n}\r\n\r\nfunction isAlphaNum(x: string) {\r\n    return isDigit(x) || isAlpha(x);\r\n}", "import { ErrorContext } from \"./errors.ts\";\r\nimport { Kind, Token } from \"./token.ts\";\r\n\r\nexport class TokenBuffer {\r\n  constructor(private err: ErrorContext) {}\r\n\r\n  private pos!: number;\r\n  private content!: Token[];\r\n  public current!: Token;\r\n  private lastToken!: Token;\r\n  public done!: boolean;\r\n\r\n  set(content: Token[]) {\r\n    this.pos = 0;\r\n    this.done = false;\r\n    this.content = content;\r\n    this.current = this.content[this.pos];\r\n    // Saving last token for better errors so when the buffer\r\n    // is finished we can see the last token it was working on\r\n    this.lastToken = this.content[this.pos];\r\n  }\r\n\r\n  next(): Token {\r\n    this.pos += 1\r\n    if (this.pos < this.content.length) {\r\n      this.current = this.content[this.pos]\r\n      this.lastToken = this.current\r\n    } else { \r\n      this.done = true\r\n      this.current = new Token(\r\n        Kind.NONE, this.lastToken.value,\r\n        this.lastToken.line, this.lastToken.lineno,\r\n        this.lastToken.start\r\n      )\r\n    }\r\n    return this.current\r\n  }\r\n\r\n  next_if(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    }\r\n    return undefined\r\n  }\r\n  try_expect(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.error(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n\r\n  expect(kind: Kind): Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.throw(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n}", "import { Token } from \"./token.ts\";\r\n\r\nconst enum ErrorLevel {\r\n  Info = \"Info\", Warning = \"Warning\", Error = \"Error\"\r\n}\r\n\r\nconst debug = true;\r\n\r\nclass Info {\r\n  error?: Error;\r\n  constructor(\r\n    public token: undefined | Token,\r\n    public msg: string,\r\n    public level = ErrorLevel.Error\r\n  ) {\r\n    if (debug) {\r\n      this.error = new Error();\r\n    }\r\n  }\r\n  static msg(msg: string) {\r\n    return new Info(undefined, msg);\r\n  }\r\n  toString(file_name = \"<eval>\"){\r\n    let output = \"\";\r\n    if (this.token) {\r\n      output += `${file_name}:${this.token.lineno}:${this.token.start}: `;\r\n    }\r\n    output += `${this.level}: ${this.msg}\\n`;\r\n    if (this.token) {\r\n      output += `${this.token.line}\\n`;\r\n      output += ' '.repeat(this.token.start) + '^';\r\n    }\r\n\r\n    if (this.error) {\r\n      console.error(this.error);\r\n      output += \"\\n\" + this.error.stack;\r\n    }\r\n\r\n    return output;\r\n  }\r\n}\r\n\r\nexport class ErrorContext {\r\n  infos: Info[] = []\r\n  warnings: Info[] = []\r\n  errors: Info[] = []\r\n\r\n  has_error() {\r\n    return this.errors.length > 0;\r\n  }\r\n\r\n  throw(token: Token, msg: string): never {\r\n    this.print_errors()\r\n    throw new Error(new Info(token, msg).toString())\r\n  }\r\n  throw_msg(msg: string): never {\r\n    this.print_errors();\r\n    throw new Error(new Info(undefined, msg).toString());\r\n  }\r\n\r\n  error(token: Token, msg: string) {\r\n    this.errors.push(new Info(token, msg))\r\n  }\r\n  error_msg(msg: string) {\r\n    this.errors.push(new Info(undefined, msg))\r\n  }\r\n  warn(token: Token, msg: string) {\r\n    this.warnings.push(new Info(token, msg, ErrorLevel.Warning))\r\n  }\r\n  warn_msg(msg: string) {\r\n    this.warnings.push(new Info(undefined, msg, ErrorLevel.Warning))\r\n  }\r\n  info(token: Token, msg: string) {\r\n    this.infos.push(new Info(token, msg, ErrorLevel.Info))\r\n  }\r\n  info_msg(msg: string) {\r\n    this.infos.push(new Info(undefined, msg, ErrorLevel.Info))\r\n  }\r\n  toString() {\r\n    let messages = \"\";\r\n    if (this.errors.length > 0) {\r\n      messages += \"[ERRORS]:\\n\"\r\n    }\r\n    for (const error of this.errors) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    if (this.warnings.length > 0) {\r\n      messages += \"[WARNINGS]:\\n\"\r\n    }\r\n    for (const error of this.warnings) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    if (this.warnings.length > 0) {\r\n      messages += \"[INFO]:\\n\"\r\n    }\r\n    for (const error of this.infos) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    return messages\r\n  }\r\n  print_errors() {\r\n    console.error(this.toString());\r\n  }\r\n}", "\r\nexport type Type = IType & (Prim | ArrayType | Pointer);\r\nexport interface IType {\r\n  toString(): string;\r\n  eq(other: Type): boolean;\r\n}\r\n\r\nexport class ArrayType implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof ArrayType && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}[]`;\r\n  }\r\n}\r\n\r\nexport class Pointer implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof Pointer && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}*`;\r\n  }\r\n}\r\n\r\nexport class Prim implements IType {\r\n  private constructor(private name: string) {\r\n\r\n  }\r\n  eq(other: Type): boolean {\r\n    return this === other;\r\n  }\r\n  static ERROR = new Prim(\"UINT\");\r\n  static UINT = new Prim(\"UINT\");\r\n  static CHAR = new Prim(\"CHAR\");\r\n  static BOOL = new Prim(\"BOOL\");\r\n\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n\r\nexport const NoType = Prim.ERROR;\r\nexport type NoType = typeof NoType;", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nexport function parseExpression(parser: Parser) {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL3, \r\n        [Kind.COND_E, Kind.COND_GE, Kind.COND_LE, Kind.COND_G, Kind.COND_L]\r\n    );\r\n}\r\n\r\nfunction genericParseBinOp(parser: Parser, func: (parser: Parser) => ast.Expression, kinds: Kind[]): ast.Expression {\r\n    let expr1 = func(parser);\r\n    //xd shoudl work i think\r\n    while (kinds.includes(parser.buf.current.kind)) {\r\n        let op: Token = parser.buf.current;\r\n        parser.buf.next();\r\n        let expr2 = func(parser);\r\n        expr1 = new ast.BinaryOp(expr1, op, expr2);\r\n    }\r\n    return expr1;\r\n}\r\n\r\nfunction parseExprL3(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL2,\r\n        [Kind.PLUS, Kind.MINUS]\r\n    );\r\n}\r\n\r\nfunction parseExprL2(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL1,\r\n        [Kind.MULT, Kind.DIV]\r\n    );\r\n}\r\n\r\nfunction parseExprL1(parser: Parser) : ast.Expression {\r\n    const current: Token = parser.buf.current;\r\n    parser.buf.next();\r\n    switch(current.kind) {\r\n        case Kind.NUMBER: { return new ast.Number(current); }\r\n        case Kind.IDENTIFIER: {\r\n            const identifier: ast.Identifier = new ast.Identifier(current);\r\n            if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n                const expr: ast.Expression = parseExpression(parser); \r\n                parser.buf.expect(Kind.CLOSE_SQUARE);\r\n                return new ast.ArrayAccess(identifier, expr);\r\n            }\r\n            return identifier;\r\n        }\r\n        case Kind.OPEN_SQUARE: {\r\n            const items: ast.Expression[] = [];\r\n            if(parser.buf.next_if(Kind.CLOSE_SQUARE)) {\r\n              return new ast.ArrayLiteral(current, items);\r\n            }\r\n            items.push(parseExpression(parser));\r\n            while(!parser.buf.current.eq(Kind.CLOSE_SQUARE)) {\r\n                parser.buf.expect(Kind.COMMA);\r\n                items.push(parseExpression(parser));\r\n            }\r\n            parser.buf.next();\r\n            return new ast.ArrayLiteral(current, items);\r\n        }\r\n        case Kind.OPEN_PARAN: {\r\n            const expr: ast.Expression = parseExpression(parser);\r\n            parser.buf.expect(Kind.CLOSE_PARAN);\r\n            return expr;\r\n        }\r\n        default: {\r\n            parser.err.throw(current, \"Failed to parser ExprL1\")\r\n        }\r\n    }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { ErrorContext } from \"../errors.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport * as Type from \"../type.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseDeclaration(parser: Parser) {\r\n  const typeToken: Token = parser.buf.expect(Kind.VAR_TYPE);\r\n  let iner: Type.Type; \r\n  if(typeToken.value == \"uint\") {\r\n      iner = Type.Prim.UINT;\r\n  }\r\n  else {\r\n    parser.err.throw(typeToken, \"Unknown type\");\r\n      //Generate error here\r\n  }\r\n\r\n  if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n    parser.buf.expect(Kind.CLOSE_SQUARE);\r\n      iner = new Type.ArrayType(iner);\r\n  }\r\n\r\n  const vartype: ast.VarType = new ast.VarType(iner, typeToken);\r\n  const identifier: Token = parser.buf.expect(Kind.IDENTIFIER);\r\n  if (parser.buf.next_if(Kind.EQUAL)) {\r\n      const expr: ast.Expression = parseExpression(parser);\r\n      parser.buf.try_expect(Kind.SEMICOLON);\r\n      return new ast.Declaration(vartype, new ast.Identifier(identifier), expr);\r\n  }\r\n  return new ast.Declaration(vartype, new ast.Identifier(identifier));\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseAssignment(parser: Parser) {\r\n    const identifier: ast.Identifier = new ast.Identifier(parser.buf.expect(Kind.IDENTIFIER));\r\n    const operators: Kind[] = [Kind.PLUS, Kind.MINUS, Kind.MULT, Kind.DIV];\r\n    let op: undefined | Token;\r\n    if(operators.includes(parser.buf.current.kind)) {\r\n        op = parser.buf.current;\r\n        parser.buf.next();\r\n    }\r\n    parser.buf.expect(Kind.EQUAL);\r\n    let expr: ast.Expression = parseExpression(parser);\r\n    if(op != undefined) {\r\n        expr = new ast.BinaryOp(identifier, op, expr);\r\n    }\r\n    parser.buf.expect(Kind.SEMICOLON);\r\n    return new ast.Assignment(identifier, expr);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\nimport { parseStatement } from \"./stmtparser.ts\";\r\n\r\nexport function parseBody(parser: Parser) : ast.Body{\r\n    const open = parser.buf.current;\r\n    parser.buf.expect(Kind.OPEN_BRACE);\r\n    const content: ast.Statement[] = []\r\n    while (!parser.buf.current.eq(Kind.CLOSE_BRACE)) {\r\n        content.push(parseStatement(parser));\r\n    }\r\n    parser.buf.next();\r\n    return new ast.Body(open, content);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseIfStatement(parser: Parser) : ast.IfStatement {\r\n    parser.buf.next();\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    const body: ast.Body = parseBody(parser);\r\n    \r\n    if(parser.buf.next_if(Kind.ELSE)) {\r\n        const elseBody: ast.Body = parseBody(parser);\r\n        return new ast.IfStatement(condition, body, elseBody);\r\n    }\r\n    else if(parser.buf.current.eq(Kind.ELIF)) {\r\n        const elsePart: ast.IfStatement = parseIfStatement(parser);\r\n        return new ast.IfStatement(condition, body, elsePart);\r\n    }\r\n    return new ast.IfStatement(condition, body, undefined);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseWhileStatement(parser: Parser) : ast.WhileStatement {\r\n    parser.buf.expect(Kind.WHILE);\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    // this should probably be done in codegen not here lol\r\n    if(condition instanceof ast.Number || condition instanceof ast.Identifier) {\r\n        const binop: ast.BinaryOp = new ast.BinaryOp(\r\n            condition,\r\n            new Token(Kind.COND_NE, \"!=\", condition.token.line, condition.token.lineno, condition.token.start),\r\n            new ast.Number(new Token(Kind.NUMBER, \"0\", condition.token.line, condition.token.lineno, condition.token.start))\r\n        )\r\n    }\r\n    //assert isinstance(condition, ast.BinaryOp)\r\n    const body: ast.Body = parseBody(parser);\r\n    return new ast.WhileStatement(condition, body);\r\n}", "import {Kind} from \"../token.ts\";\r\nimport * as ast from \"../ast.ts\";\r\nimport {Parser} from \"../parser.ts\"\r\nimport {parseDeclaration} from \"./decparser.ts\";\r\nimport {parseAssignment} from \"./assignparser.ts\"\r\nimport {parseBody} from \"./bodyparser.ts\";\r\nimport { parseIfStatement } from \"./ifparser.ts\";\r\nimport { parseWhileStatement } from \"./whileparser.ts\";\r\n\r\n\r\nexport function parseStatement(parser: Parser) : ast.Statement {\r\n    switch (parser.buf.current.kind) {\r\n        case Kind.VAR_TYPE: return parseDeclaration(parser);\r\n        case Kind.IDENTIFIER: return parseAssignment(parser);\r\n        case Kind.IF: return parseIfStatement(parser);\r\n        case Kind.WHILE: return parseWhileStatement(parser);\r\n        case Kind.OPEN_BRACE: return parseBody(parser);\r\n        default: parser.err.throw(parser.buf.current, \"\")\r\n    }\r\n}", "import * as ast from \"./ast.ts\";\r\nimport {Kind, Token} from \"./token.ts\";\r\nimport {TokenBuffer} from \"./tokenbuffer.ts\";\r\nimport { ErrorContext } from \"./errors.ts\";\r\n\r\nimport { parseStatement } from \"./parser/stmtparser.ts\";\r\nexport class Parser {\r\n    err: ErrorContext; \r\n    buf: TokenBuffer;\r\n\r\n    constructor() {\r\n        this.err = new ErrorContext();\r\n        this.buf = new TokenBuffer(this.err);\r\n    }\r\n\r\n    parse(tokens: Token[]) : ast.Statement[] {\r\n        tokens = tokens.filter(token => \r\n            token.kind !== Kind.WHITESPACE && token.kind !== Kind.COMMENT\r\n        );\r\n        const ast_nodes: ast.Statement[] = [];\r\n        this.buf.set(tokens);\r\n        while(!this.buf.done) {\r\n            ast_nodes.push(parseStatement(this));\r\n        }\r\n        return ast_nodes;\r\n\r\n    }\r\n}", "import { Type } from \"../type.ts\";\r\nimport { Scope } from \"./scope.ts\";\r\n\r\nexport class Variable {\r\n  constructor(public scope: Scope, public type: Type) {\r\n\r\n  }\r\n}", "import { Type } from \"../type.ts\";\r\nimport { Variable } from \"./variable.ts\";\r\n\r\nexport class Scopes {\r\n  top = new Scope();\r\n  put(name: string, type: Type): void | Variable {\r\n    return this.top.put(name, type);\r\n  }\r\n  get(name: string): void | Variable {\r\n    return this.top.get(name);\r\n  }\r\n\r\n  push() {\r\n    this.top = new Scope(this.top);\r\n  }\r\n  pop(): boolean {\r\n    if (this.top.parent === undefined) {\r\n      return false\r\n    }\r\n    this.top = this.top.parent;\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class Scope {\r\n  variables: Record<string, Variable | void> = {}; \r\n  constructor(readonly parent?: Scope) {}\r\n\r\n  put(name: string, type: Type): void | Variable {\r\n    if (this.get(name)) {\r\n      return undefined;\r\n    }\r\n    const variable = new Variable(this, type);\r\n    this.variables[name] = variable;\r\n  }\r\n\r\n  get(name: string): void | Variable {\r\n    return this.variables[name] ?? this.parent?.get(name);\r\n  }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind } from \"../token.ts\";\r\nimport { ArrayType, NoType, Prim, Type } from \"../type.ts\";\r\nimport { TypeChecker } from \"./typechecker.ts\";\r\n\r\nexport function checkCondition(checker: TypeChecker, node: ast.Expression): void {\r\n    checkExpr(checker, node)\r\n    checker.expect(node, Prim.BOOL);\r\n}\r\n\r\nexport function checkExpr(checker: TypeChecker, node: ast.Expression): Type {\r\n    if (node instanceof ast.BinaryOp) {\r\n        return checkBinaryOp(checker, node);\r\n    } else if (node instanceof ast.Number) {\r\n        return checker.set(node, Prim.UINT);\r\n    } else if (node instanceof ast.Identifier) {\r\n        const variable = checker.scopes.get(node.token.value);\r\n        console.log(checker.scopes);\r\n        if (!variable) {\r\n            checker.err.error(node.token, `Variable is undefined`);\r\n            return checker.set(node, NoType);\r\n        }\r\n        console.log(variable, node);\r\n        return checker.set(node, variable.type);\r\n    } else if (node instanceof ast.ArrayLiteral) {\r\n        return checkArrayLiteral(checker, node);\r\n    } else if (node instanceof ast.ArrayAccess) {\r\n        return checkArrayAccess(checker, node);\r\n    }\r\n}\r\n\r\nfunction checkArrayLiteral(checker: TypeChecker, node: ast.ArrayLiteral): Type {\r\n    // fixme: infer the type depending on context\r\n    if (node.items.length == 0) {\r\n        checker.err.error(node.start, \"Empty array\");\r\n        return checker.set(node, NoType);\r\n    }\r\n    const type = checkExpr(checker, node.items[0]);\r\n    for (let i = 1; i < node.items.length; i++) {\r\n        const other = checkExpr(checker, node.items[i]);\r\n        if (type && other !== type) {\r\n            checker.err.error(node.items[i].start, \"Types should match within an array\");\r\n        }\r\n    }\r\n    if (!type) {\r\n        return checker.set(node, NoType);\r\n    }\r\n    return checker.set(node, new ArrayType(type));\r\n}\r\n\r\nfunction checkArrayAccess(checker: TypeChecker, node: ast.ArrayAccess): Type {\r\n    const array = checkExpr(checker, node.array);\r\n    if (!(array instanceof ArrayType)) {\r\n        checker.err.error(node.array.start, \"Value is not indexable\");\r\n    }\r\n    const index = checkExpr(checker, node.index);\r\n    if (index === Prim.UINT) {\r\n        checker.err.error(node.index.start, \"Index should be a uint\");\r\n    }\r\n    if (array instanceof ArrayType) {\r\n        return checker.set(node, array.iner);\r\n    }\r\n    return checker.set(node, NoType);\r\n}\r\n\r\nfunction checkBinaryOp(checker: TypeChecker, node: ast.BinaryOp): Type {\r\n    const left = checkExpr(checker, node.expr1);\r\n    const right = checkExpr(checker, node.expr2);\r\n    if (left === NoType || right === NoType) {\r\n        console.log(\">>>>\", checker.type(node.expr1), left, node.expr2, right);\r\n        return checker.set(node, NoType);\r\n    }\r\n    if (left !== right) {\r\n        checker.err.error(node.op, `Type ${left} and ${right} do not match`);\r\n        return checker.set(node, NoType);\r\n    }\r\n\r\n    switch (node.op.kind) {\r\n        case Kind.COND_E: case Kind.COND_NE:\r\n        case Kind.COND_GE: case Kind.COND_G:\r\n        case Kind.COND_LE: case Kind.COND_L: {\r\n            console.log(\"node\", node);\r\n            checker.expect(node.expr1, Prim.UINT, Prim.CHAR);\r\n            checker.expect(node.expr2, Prim.UINT, Prim.CHAR);\r\n            return checker.set(node, Prim.BOOL);\r\n        }\r\n\r\n        default: return checker.set(node, left);\r\n    }\r\n}", "import { ErrorContext } from \"../errors.ts\";\r\nimport * as ast from \"../ast.ts\";\r\nimport { NoType, Prim, Type } from \"../type.ts\";\r\nimport { Scopes } from \"./scope.ts\";\r\nimport { checkCondition, checkExpr } from \"./exprchecker.ts\";\r\n\r\nexport class TypeChecker {\r\n    constructor(public err: ErrorContext) {}\r\n\r\n    types = new Map<ast.AstNode, Type>();\r\n    scopes = new Scopes();\r\n\r\n    popScope() {\r\n        if (!this.scopes.pop()){\r\n            this.err.throw_msg(\"Poped last scope\");\r\n        }\r\n    }\r\n\r\n    check(tree: ast.Statement[]) {\r\n        for (const node of tree) {\r\n            checkStatement(this, node);\r\n        }\r\n    }\r\n    type(tree: ast.AstNode) {\r\n        return this.types.get(tree);\r\n    }\r\n\r\n    set(tree: ast.AstNode, type: Type): Type {\r\n        this.types.set(tree, type);\r\n        return type;\r\n    }\r\n    expect(tree: ast.AstNode, ...types: Type[]): Type {\r\n        const type = this.type(tree);\r\n        if (type === undefined) {\r\n            console.log(\"no type\", tree);\r\n            this.err.warn(tree.start, `Missing type on node ${tree}`);\r\n            return this.set(tree, NoType);\r\n        }\r\n        for (const expect of types) {\r\n            if (type.eq(expect)) {\r\n                return type;\r\n            }\r\n        }\r\n        return this.set(tree, NoType);\r\n\r\n    } \r\n}\r\n\r\nfunction checkStatement(checker: TypeChecker, node: ast.Statement) {\r\n    if (node instanceof ast.Body) {\r\n        checkBody(checker, node);\r\n    } else if (node instanceof ast.IfStatement) {\r\n        checkIf(checker, node);\r\n    } else if (node instanceof ast.WhileStatement) {\r\n        checkWhile(checker, node);\r\n    } else if (node instanceof ast.Assignment) {\r\n        checkAssignment(checker, node);\r\n    } else if (node instanceof ast.Declaration) {\r\n        checkDeclaration(checker, node);\r\n    } else if (node instanceof ast.MacroDeclaration) {\r\n        checkMacroDeclaration(checker, node);\r\n    } else if (node instanceof ast.MacroCall) {\r\n        checkMacroCall(checker, node);\r\n    }\r\n}\r\n\r\n\r\nfunction checkBody(checker: TypeChecker, tree: ast.Body) {\r\n    checker.scopes.push();\r\n    for (const statement of tree.content) {\r\n        checkStatement(checker, statement);\r\n    }\r\n    checker.popScope();\r\n}\r\n\r\nfunction checkIf(checker: TypeChecker, tree: ast.IfStatement) {\r\n    checkCondition(checker, tree.condition);\r\n    checkBody(checker, tree.body);\r\n    if (tree.child) {\r\n        checkStatement(checker, tree.child);\r\n    }\r\n}\r\nfunction checkWhile(checker: TypeChecker, tree: ast.WhileStatement) {\r\n    checkCondition(checker, tree.condition);\r\n    checkStatement(checker, tree.body);\r\n}\r\n\r\nfunction checkAssignment(checker: TypeChecker, tree: ast.Assignment) {\r\n    checkExpr(checker, tree.expr);\r\n}\r\nfunction checkDeclaration(checker: TypeChecker, tree: ast.Declaration) {\r\n    checker.scopes.put(tree.name.token.value, Prim.UINT);\r\n\r\n    if (tree.expr) {\r\n        checkExpr(checker, tree.expr);\r\n    }\r\n}\r\nfunction checkMacroDeclaration(checker: TypeChecker, tree: ast.MacroDeclaration) {\r\n\r\n}\r\nfunction checkMacroCall(checker: TypeChecker, tree: ast.MacroCall) {\r\n\r\n}", "type L<T extends string | HTMLElement> =  T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T]: (T extends HTMLElement ? T : HTMLElement)\r\ntype RPartial<T> = {[K in keyof T]?: T[K] extends object ? RPartial<T[K]> : T[K]};\r\n\r\n/*\r\na new HTML-element is made with the tag\r\nif there is an object apply its attributes to the element\r\nappend each given child to the element\r\n*/\r\nexport function l<T extends keyof HTMLElementTagNameMap | HTMLElement>\r\n    (tagOrElement: T = \"DIV\" as any, attributes: RPartial<L<T>> & {tagName?: never} = {}, ...children: (Node|string)[]): L<T>\r\n{\r\n    const element: HTMLElement = typeof tagOrElement === \"string\" ? document.createElement(tagOrElement) : tagOrElement;\r\n    attribute(element, attributes as any)\r\n    element.append(...children)\r\n    return element as any;\r\n}\r\n\r\n// applies all attributes in an object to a HTML-element\r\nfunction attribute<T extends Record<string, any>>(element: T, attributes: RPartial<T>){\r\n    for (const [key, value] of Object.entries(attributes)){\r\n        if (typeof value === \"object\"){\r\n            attribute(element[key], value);\r\n        } else {\r\n            element[key as keyof T] = value;\r\n        }\r\n    }\r\n}\r\n", "import { lex } from \"../../src/lexer\";\r\nimport { Token } from \"../../src/token\";\r\nimport { l } from \"./l\"\r\n\r\nexport class Editor_Window extends HTMLElement {\r\n    private line_nrs: HTMLElement;\r\n    private code: HTMLElement;\r\n    private input: HTMLTextAreaElement;\r\n    private colors: HTMLElement;\r\n    // private profile_check = document.createElement(\"input\");\r\n    private profiled: boolean[] = [];\r\n    private profile_present: boolean = false;\r\n    private lines: string[] = [];\r\n    tab_width = 4\r\n    constructor(){\r\n        super();\r\n        l(this, {}, \r\n            this.line_nrs = l(\"div\", {className: \"line-nrs\"}),\r\n            this.code = l(\"div\", {className: \"code\"},\r\n                this.input = l(\"textarea\", {spellcheck: false}),\r\n                this.colors = l(\"code\", {className: \"colors\"})\r\n            ),\r\n        );\r\n\r\n        this.input.addEventListener(\"input\", this.input_cb.bind(this));\r\n\r\n        this.input.addEventListener(\"keydown\", this.keydown_cb.bind(this));\r\n        const resize_observer = new ResizeObserver(() => this.render_lines());\r\n        resize_observer.observe(this);\r\n\r\n\r\n        this.onscroll = () => this.render_lines();\r\n    }\r\n    get value(){\r\n        return this.input.value;\r\n    }\r\n    set value(value){\r\n        this.input.value = value;\r\n        this.input_cb()\r\n    }\r\n    private pc_line = 0;\r\n    public set_pc_line(line: number){\r\n        const old = this.line_nrs.children[this.pc_line];\r\n        if (old){\r\n            old.classList.remove(\"pc-line\");\r\n        }\r\n\r\n        const child = this.line_nrs.children[line];\r\n        if (child){\r\n            child.classList.add(\"pc-line\");\r\n        }\r\n        this.pc_line = line;\r\n    }\r\n    private keydown_cb(event: KeyboardEvent){\r\n        if (event.key === \"Tab\"){\r\n            event.preventDefault();\r\n            let start = this.input.selectionStart;\r\n            let end = this.input.selectionEnd;\r\n            if (!event.shiftKey && start === end){\r\n                const value = this.input.value;\r\n                const line_offset = start - line_start(value, start);\r\n                const add_count = this.tab_width - (line_offset % this.tab_width) || this.tab_width\r\n                this.input.value = str_splice(value, start, 0, \" \".repeat(add_count));\r\n                this.input.selectionStart = this.input.selectionEnd = start + add_count;\r\n            }\r\n            this.input_cb();\r\n        }\r\n    }\r\n    private input_cb(){\r\n        this.render_lines();\r\n        this.call_input_listeners();\r\n    }\r\n\r\n    private render_lines(){\r\n        this.input.style.height = \"0px\";\r\n        const height = this.input.scrollHeight\r\n        this.input.style.height = height + \"px\";\r\n\r\n        this.input.style.width = \"0px\";\r\n        this.input.style.width = this.input.scrollWidth + \"px\";\r\n        \r\n        const lines = this.input.value.split(\"\\n\");\r\n        this.lines = lines;\r\n        {\r\n            const width = (lines.length+\"\").length\r\n            const start_lines = this.line_nrs.children.length\r\n            const delta_lines = lines.length - start_lines;\r\n            if (delta_lines > 0){\r\n                for (let i = 0; i < delta_lines; i++){\r\n                    const div = this.line_nrs.appendChild(document.createElement(\"div\"));\r\n                    div.textContent = (\"\"+(start_lines+i+1)).padStart(width);\r\n                }\r\n            } else {\r\n                for (let i = 0; i < -delta_lines; i++){\r\n                    this.line_nrs.lastChild?.remove()\r\n                }\r\n            }\r\n        }\r\n\r\n        const ch = this.input.scrollHeight / Math.max(1, this.lines.length);\r\n    \r\n        const pixel_start = this.scrollTop;\r\n        const pixel_end = Math.min(pixel_start + this.clientHeight, this.input.scrollHeight);\r\n\r\n        const start = Math.floor(pixel_start / ch);\r\n        const end = Math.min(this.lines.length, Math.ceil(pixel_end / ch));\r\n\r\n        this.colors.style.top = (start*ch) + \"px\";\r\n\r\n\r\n        let div: Element | null = this.colors.firstElementChild;\r\n        const all_tokens = lex(this.lines);\r\n        // for (let i = 0; )\r\n\r\n        console.log(all_tokens);\r\n        let token_i = 0;\r\n\r\n        for (let i = start; i < end; i++) {\r\n            const line = this.lines[i].replaceAll(\"\\r\", \"\");\r\n            if (div === null) {\r\n                div = document.createElement(\"div\");\r\n                this.colors.appendChild(div);\r\n            }\r\n\r\n            div.innerHTML = \"\";\r\n            let start = 0;\r\n\r\n            let span: Element | null = div.firstElementChild;\r\n            if (line.length == 0) {\r\n                div.innerHTML = \"<span> </span>\";\r\n            } else {\r\n                while (token_i < all_tokens.length){\r\n                    const token = all_tokens[token_i];\r\n                    if ( token.lineno > i + 1) {\r\n                        break;\r\n                    }\r\n                    console.log(token.start, start);\r\n                    if (token.start > start - 1) {\r\n                        document.title = \"wtf\";\r\n                        if (span === null){\r\n                            span = document.createElement(\"span\");\r\n                            div.appendChild(span);\r\n                        }\r\n                        span.textContent = \" \".repeat(token.start - start);\r\n                        span.className = \"white\";\r\n                        span = span.nextElementSibling;\r\n                    }\r\n\r\n                    start = token.start + token.value.length;\r\n                    token_i += 1;\r\n\r\n                    if (span === null){\r\n                        span = document.createElement(\"span\");\r\n                        div.appendChild(span);\r\n                    }\r\n                    span.textContent = token.value;\r\n                    span.className = token.kind;\r\n\r\n                    span = span.nextElementSibling;\r\n                }\r\n            }\r\n\r\n            while (span !== null){\r\n                const next = span.nextElementSibling;\r\n                div.removeChild(span);\r\n                span = next\r\n            }\r\n            div = div.nextElementSibling;\r\n        }\r\n\r\n        while (div !== null){\r\n            const next = div.nextElementSibling;\r\n            this.colors.removeChild(div);\r\n            div = next;\r\n        }\r\n    }\r\n\r\n    private call_input_listeners(){\r\n        for (const listener of this.input_listeners){\r\n            listener.call(this, new Event(\"input\"));\r\n        }\r\n    }\r\n\r\n    private input_listeners: ((this: GlobalEventHandlers, event: Event) => void)[] = [];\r\n    set oninput(cb: (this: GlobalEventHandlers, event: Event) => void){\r\n        this.input_listeners.push(cb);\r\n    }\r\n}\r\ncustomElements.define(\"editor-window\", Editor_Window);\r\n\r\n\r\nfunction str_splice(string: string, index: number, delete_count: number, insert: string){\r\n    return string.slice(0, index) + insert + string.slice(index + delete_count);\r\n}\r\n\r\n\r\nfunction foreach_line_selected(string: string, start: number, end: number, callback: (i: number) => string) {\r\n    const first_line = line_start(string, start);\r\n    let i = string.indexOf(\"\\n\", first_line) + 1 || string.length;\r\n    let line_count = 1;\r\n    for (;i < end; i = string.indexOf(\"\\n\", i) + 1 || string.length){\r\n        line_count++;\r\n    }\r\n    for (let line = 0, i = first_line; line < line_count; line++){\r\n        string = callback(i);\r\n        i = string.indexOf(\"\\n\", i) + 1 || string.length;\r\n    }\r\n    return string;\r\n}\r\n\r\nfunction line_start(string: string, index: number): number {\r\n    let i = 0, line_start = 0;\r\n    for (;i <= index; i = string.indexOf(\"\\n\", i) + 1 || string.length){\r\n        line_start = i;\r\n        if (i >= string.length){\r\n            line_start+1;\r\n            break;\r\n        }\r\n    }\r\n    return line_start;\r\n}\r\n", "import { CodeGeneration } from \"../src/codegen\";\r\nimport { lex } from \"../src/lexer\";\r\nimport { Parser } from \"../src/parser\";\r\nimport { TypeChecker } from \"../src/typecheck/typechecker\";\r\nimport \"./editor/editor\";\r\n\r\nconsole.log(\"hello world\");\r\n{\r\nconst output_container = document.getElementById(\"outputs\") as HTMLOutputElement;\r\nconst buttons = output_container.querySelectorAll(\"nav button\") as NodeListOf<HTMLButtonElement>;\r\nconst divs = output_container.querySelectorAll(\"div\");\r\n\r\nfunction select(select: number) {\r\n    for (let i = 0; i < divs.length; i++) {\r\n        if (i === select) {\r\n            divs[i].classList.remove(\"hidden\");\r\n        } else {\r\n            divs[i].classList.add(\"hidden\");\r\n        }\r\n    }\r\n}\r\nselect(2);\r\nbuttons.forEach((button, i) => {\r\n    button.onclick = e => select(i);\r\n});\r\n}\r\n{\r\n    const code = document.getElementById(\"code\") as HTMLTextAreaElement;\r\n    const errorOutput = document.getElementById(\"error\") as HTMLOutputElement;\r\n    const lexOutput = document.getElementById(\"lexer\") as HTMLOutputElement;\r\n    const parseOutput = document.getElementById(\"parser\") as HTMLOutputElement;\r\n    const codegenOutput = document.getElementById(\"urcl\") as HTMLOutputElement;\r\n    const error_button = document.getElementById(\"error-button\") as HTMLButtonElement;\r\n\r\n    code.oninput = oninput;\r\n    function oninput() {\r\n        errorOutput.value = \"\";\r\n        lexOutput.value = \"\";\r\n        parseOutput.value = \"\";\r\n        error_button.classList.remove(\"error\");\r\n        try {\r\n        const results = lex(code.value.split(\"\\n\"));\r\n        let lexString = \"\";\r\n        for (const r of results) {\r\n            lexString += r + \"\\n\";\r\n        }\r\n        lexOutput.value = lexString;\r\n        \r\n        const parser = new Parser();\r\n        const parseResults = parser.parse(results);\r\n        let parseString = \"\";\r\n        for (const r of parseResults) {\r\n            console.log(r);\r\n            parseString += r.toString() + \"\\n\"; // JSON.stringify(r, null, 2) + \"\\n\";\r\n        } \r\n        parseOutput.value = parseString;\r\n\r\n        const checkResults = new TypeChecker(parser.err).check(parseResults);\r\n\r\n        // TODO: skip codegen on error\r\n        const codegen = new CodeGeneration(7);\r\n        const asms = codegen.gen(parseResults);\r\n        let result = \"\";\r\n        for (const asm of asms) {\r\n            console.log(asm);\r\n            const token = asm.source.start;\r\n            //result += \"// \" + token.lineno + \"\\n\";\r\n          let instrsInAsm = asm.instrs;\r\n          for (const instr of instrsInAsm) {\r\n            result += instr + \"\\n\";\r\n          }\r\n          result += \"\\n\";\r\n        }\r\n        console.log(result);\r\n        console.log(codegenOutput);\r\n        codegenOutput.value = result;\r\n\r\n        console.log(parser.err);\r\n        if (parser.err.has_error()) {\r\n            errorOutput.value = parser.err.toString();\r\n            error_button.classList.add(\"error\");\r\n        }\r\n\r\n        } catch (e) {\r\n            if (e instanceof Error) {\r\n                errorOutput.value = \"[ERROR]:\\n\" + e.message;\r\n            }\r\n            error_button.classList.add(\"error\");\r\n        }\r\n    };\r\n    oninput();\r\n}"],
  "mappings": "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",
  "names": []
}
