{
  "version": 3,
  "sources": ["../src/token.ts", "../src/lexer.ts", "../src/tokenbuffer.ts", "../src/errors.ts", "../src/ast.ts", "../src/type.ts", "../src/parser/exprparser.ts", "../src/parser/decparser.ts", "../src/parser/assignparser.ts", "../src/parser/bodyparser.ts", "../src/parser/ifparser.ts", "../src/parser/whileparser.ts", "../src/parser/stmtparser.ts", "../src/parser.ts"],
  "sourcesContent": ["export const enum Kind {\r\n  VAR_TYPE = \"VAR_TYPE\",\r\n\r\n  IDENTIFIER = \"IDENTIFIER\",\r\n  NUMBER = \"NUMBER\",\r\n  EQUAL = \"EQUAL\",\r\n  PLUS = \"PLUS\",\r\n  MINUS = \"MINUS\",\r\n  MULT = \"MULT\",\r\n  DIV = \"DIV\",\r\n\r\n  MACROCALL = \"MACROCALL\",\r\n\r\n  COMMENT = \"COMMENT\",\r\n\r\n  OPEN_BRACE = \"OPEN_BRACE\",\r\n  CLOSE_BRACE = \"CLOSE_BRACE\",\r\n  IF = \"IF\",\r\n  ELSE = \"ELSE\",\r\n  ELIF = \"ELIF\",\r\n  WHILE = \"WHILE\",\r\n  MACRO = \"MACRO\",\r\n  COND_G = \"COND_G\",\r\n  COND_L = \"COND_L\",\r\n  COND_E = \"COND_E\",\r\n  COND_LE = \"COND_LE\",\r\n  COND_NE = \"COND_NE\",\r\n  COND_GE = \"COND_GE\",\r\n  COMMA = \"COMMA\",\r\n\r\n  OPEN_PARAN = \"OPEN_PARAN\",\r\n  CLOSE_PARAN = \"CLOSE_PARAN\",\r\n\r\n  OPEN_SQUARE = \"OPEN_SQUARE\",\r\n  CLOSE_SQUARE = \"CLOSE_SQUARE\",\r\n\r\n  SEMICOLON = \"SEMICOLON\",\r\n\r\n  NONE = \"NONE\",\r\n}\r\n\r\nexport class Token {\r\n  constructor(\r\n    public kind: Kind,\r\n    public value: string,\r\n    public line: string,\r\n    public lineno: number,\r\n    public start: number,\r\n  ){}\r\n\r\n  eq(kind: Kind): boolean {\r\n    return this.kind == kind;\r\n  }\r\n\r\n  toString(): string {\r\n    return `Token(${this.kind} ${this.lineno}:${this.start} ${JSON.stringify(this.value)})`;\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\n\r\nclass Buffer {\r\n    current!: string\r\n    pos!: number\r\n    done!: boolean\r\n    line!: string\r\n    set(line: string) {\r\n        this.current = line[0]\r\n        this.pos = 0\r\n        this.done = false\r\n        this.line = line\r\n    }\r\n\r\n    next(): string {\r\n        this.pos += 1\r\n        if (this.pos < this.line.length) {\r\n            this.current = this.line[this.pos]\r\n        } else {\r\n            this.done = true\r\n            this.current = '\\0'\r\n        }\r\n        return this.current\r\n    }\r\n}\r\n\r\nconst keywords: Record<string, Kind> = {\r\n    \"uint\": Kind.VAR_TYPE,\r\n    \"char\": Kind.VAR_TYPE,\r\n    \"if\": Kind.IF,\r\n    \"else\": Kind.ELSE,\r\n    \"elif\": Kind.ELIF,\r\n    \"while\": Kind.WHILE,\r\n    \"macro\": Kind.MACRO,\r\n}\r\n\r\nconst symbols : Record<string, Kind> = {\r\n    '=': Kind.EQUAL,\r\n    ';': Kind.SEMICOLON,\r\n    '{': Kind.OPEN_BRACE,\r\n    '}': Kind.CLOSE_BRACE,\r\n    '>': Kind.COND_G,\r\n    '<': Kind.COND_L,\r\n    '+': Kind.PLUS,\r\n    '-': Kind.MINUS,\r\n    '*': Kind.MULT,\r\n    '(': Kind.OPEN_PARAN,\r\n    ')': Kind.CLOSE_PARAN,\r\n    ',': Kind.COMMA,\r\n    '/': Kind.DIV,\r\n    '[': Kind.OPEN_SQUARE,\r\n    ']': Kind.CLOSE_SQUARE,\r\n}\r\n\r\nconst double_symbols: Record<string, Kind> = {\r\n    \"==\": Kind.COND_E,\r\n    \">=\": Kind.COND_GE,\r\n    \"<=\": Kind.COND_LE,\r\n    \"!=\": Kind.COND_NE,\r\n    \"//\": Kind.COMMENT,\r\n}\r\n\r\nexport function lex(lines: string[], file_name = \"<eval>\") : Token[]{\r\n    const tokens: Token[] = []\r\n    const buf: Buffer = new Buffer()\r\n    let lineno = 0;\r\n    for (const line of lines) {\r\n        lineno++;\r\n        buf.set(line);\r\n        while (!buf.done) {\r\n            if (isDigit(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let num: string = buf.current;\r\n                while (isDigit(buf.next())) {\r\n                    num += buf.current;\r\n                }\r\n                tokens.push(\r\n                    new Token(Kind.NUMBER, num, line, lineno, start)\r\n                );\r\n            }\r\n            else if(isAlpha(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let word: string = buf.current;\r\n                while (isAlpha(buf.next())) {\r\n                    word += buf.current \r\n                }\r\n                let kind: Kind = Kind.IDENTIFIER;\r\n                if (word in keywords) {\r\n                    kind = keywords[word];\r\n                }\r\n                if (buf.current === \"!\") {\r\n                    buf.next();\r\n                    kind = Kind.MACROCALL;\r\n                }\r\n                tokens.push(\r\n                    new Token(kind, word, line, lineno, start)\r\n                );\r\n            }\r\n            else {\r\n                if (buf.current in symbols) {\r\n                    let current: string = buf.current;\r\n                    let symbol_kind: Kind = symbols[current];\r\n                    buf.next();\r\n                    const double_symbol = buf.current + current;\r\n                    if (double_symbol in double_symbols) {\r\n                        symbol_kind = double_symbols[double_symbol];\r\n                        current = double_symbol;\r\n                        buf.next();\r\n                    }\r\n\r\n                    if (symbol_kind === Kind.COMMENT) {\r\n                        buf.done = true;\r\n                    } else {\r\n                        tokens.push(\r\n                            new Token(symbol_kind, current, line, lineno, buf.pos)\r\n                        );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    buf.next();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n\r\nfunction isDigit(x: string) {\r\n    return \"0123456789\".includes(x);\r\n}\r\n\r\nfunction isAlpha(x: string) {\r\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(x);\r\n}\r\n\r\nfunction isAlphaNum(x: string) {\r\n    return isDigit(x) || isAlpha(x);\r\n}", "import { ErrorContext } from \"./errors.ts\";\r\nimport { Kind, Token } from \"./token.ts\";\r\n\r\nexport class TokenBuffer {\r\n  constructor(private err: ErrorContext) {}\r\n\r\n  private pos!: number;\r\n  private content!: Token[];\r\n  public current!: Token;\r\n  private lastToken!: Token;\r\n  public done!: boolean;\r\n\r\n  set(content: Token[]) {\r\n    this.pos = 0;\r\n    this.done = false;\r\n    this.content = content;\r\n    this.current = this.content[this.pos];\r\n    // Saving last token for better errors so when the buffer\r\n    // is finished we can see the last token it was working on\r\n    this.lastToken = this.content[this.pos];\r\n  }\r\n\r\n  next(): Token {\r\n    this.pos += 1\r\n    if (this.pos < this.content.length) {\r\n      this.current = this.content[this.pos]\r\n      this.lastToken = this.current\r\n    } else { \r\n      this.done = true\r\n      this.current = new Token(\r\n        Kind.NONE, this.lastToken.value,\r\n        this.lastToken.line, this.lastToken.lineno,\r\n        this.lastToken.start\r\n      )\r\n    }\r\n    return this.current\r\n  }\r\n\r\n  next_if(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    }\r\n    return undefined\r\n  }\r\n  try_expect(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.error(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n\r\n  expect(kind: Kind): Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.throw(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n}", "import { Token } from \"./token.ts\";\r\n\r\nconst enum ErrorLevel {\r\n  Info = \"Info\", Warning = \"Warning\", Error = \"Error\"\r\n}\r\n\r\nclass Info {\r\n  constructor(\r\n    public token: undefined | Token,\r\n    public msg: string,\r\n    public level = ErrorLevel.Error\r\n  ) {}\r\n  static msg(msg: string) {\r\n    return new Info(undefined, msg);\r\n  }\r\n  toString(file_name = \"<eval>\"){\r\n    let output = \"\";\r\n    if (this.token) {\r\n      output += `${file_name}:${this.token.lineno}:${this.token.start}: `;\r\n    }\r\n    output += `${this.level}: ${this.msg}\\n`;\r\n    if (this.token) {\r\n      output += `${this.token.line}\\n`;\r\n      output += ' '.repeat(this.token.start-1) + '^';\r\n    }\r\n\r\n    return output;\r\n  }\r\n}\r\n\r\nexport class ErrorContext {\r\n  infos: Info[] = []\r\n  warnings: Info[] = []\r\n  errors: Info[] = []\r\n\r\n  has_error() {\r\n    return this.errors.length > 0;\r\n  }\r\n\r\n  throw(token: Token, msg: string): never {\r\n    this.print_errors()\r\n    throw new Error(new Info(token, msg).toString())\r\n  }\r\n  throw_msg(msg: string): never {\r\n    this.print_errors();\r\n    throw new Error(new Info(undefined, msg).toString());\r\n  }\r\n\r\n  error(token: Token, msg: string) {\r\n    this.infos.push(new Info(token, msg))\r\n  }\r\n  error_msg(msg: string) {\r\n    this.infos.push(new Info(undefined, msg))\r\n  }\r\n  warn(token: Token, msg: string) {\r\n    this.warnings.push(new Info(token, msg, ErrorLevel.Warning))\r\n  }\r\n  warn_msg(msg: string) {\r\n    this.warnings.push(new Info(undefined, msg, ErrorLevel.Warning))\r\n  }\r\n  info(token: Token, msg: string) {\r\n    this.errors.push(new Info(token, msg, ErrorLevel.Info))\r\n  }\r\n  info_msg(msg: string) {\r\n    this.errors.push(new Info(undefined, msg, ErrorLevel.Info))\r\n  }\r\n  toString() {\r\n    let messages = \"\";\r\n    if (this.errors) {\r\n      messages += \"[ERRORS]:\\n\"\r\n    }\r\n    for (const error of this.errors) {\r\n      messages += error.toString();\r\n    }\r\n\r\n    if (this.warnings) {\r\n      messages += \"[WARNINGS]:\\n\"\r\n    }\r\n    for (const error of this.warnings) {\r\n      messages += error.toString();\r\n    }\r\n\r\n    if (this.warnings) {\r\n      messages += \"[INFO]:\\n\"\r\n    }\r\n    for (const error of this.infos) {\r\n      messages += error.toString();\r\n    }\r\n\r\n    return messages\r\n  }\r\n  print_errors() {\r\n    console.error(this.toString());\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\nimport { Type } from \"./type.ts\";\r\n\r\nexport interface AstNode {\r\n\r\n}\r\n\r\n//Statements\r\n//=============================================\r\nexport type Statement = Body | IfStatement | WhileStatement\r\n    | MacroDeclaration | MacroCall | Declaration | Assignment;\r\n\r\nexport interface IStatement extends AstNode {}\r\n\r\nexport class Body implements IStatement {\r\n    constructor(public content: Statement[]) {}\r\n\r\n    toString() {\r\n      return `Body {\\n${this.content.join(\"\\n\")}\\n}`;\r\n    }\r\n}\r\n\r\nexport class IfStatement implements IStatement {\r\n    constructor(\r\n        public condition: IExpression,\r\n        public body: Body,\r\n        public child: Body | IfStatement | undefined\r\n    ) {\r\n    }\r\n\r\n    toString() {\r\n      return `If(\\n\\t${this.condition} \\n\\t${this.body} else \\n\\t${this.child ?? \"nothing\"})`;\r\n    }\r\n  }\r\n\r\n  export class WhileStatement implements IStatement {\r\n    constructor(public condition: IExpression, public body: Body) {}\r\n\r\n    toString() {\r\n      return `While(\\n\\t${this.condition} \\n\\t${this.body})`;\r\n    }\r\n  }\r\n  \r\nexport class MacroDeclaration implements IStatement {\r\n    constructor(\r\n        public name: Identifier,\r\n        public args: Expression[],\r\n        public body: Body\r\n    ) {}\r\n\r\n    toString() {\r\n      return `MacroDecl(${this.name} ${this.args.join(\", \")};\\n${this.body})`;\r\n    }\r\n  }\r\n  \r\n  export class MacroCall implements IStatement {\r\n    constructor(public name: Identifier, public args: IExpression[]) {}\r\n    toString() {\r\n      return `MacroCall(${this.name} ${this.args.join(\", \")}})`;\r\n    }\r\n}\r\n\r\nexport class Declaration implements IStatement {\r\n    constructor(\r\n        public vartype: VarType,\r\n        public name: Identifier,\r\n        public expr?: IExpression\r\n    ) {}\r\n\r\n    toString() {\r\n      return `Declaration(${this.vartype} ${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class Assignment implements IStatement {\r\n    constructor(public name: Identifier, public expr: IExpression) {}\r\n    toString() {\r\n      return `Assignment(${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class VarType {\r\n    constructor(public type: Type, public token: Token) {}\r\n    toString() {\r\n      return `VarType(${this.type} ${this.token})`;\r\n    }\r\n}\r\n\r\n//Expressions\r\n//=============================================\r\nexport type Expression = Number | Identifier | BinaryOp | ArrayLiteral | ArrayAccess;\r\nexport interface IExpression {}\r\n\r\nexport class Number implements IExpression {\r\n    constructor(public token: Token) {}\r\n    toString() {\r\n      return `Number(${this.token})`\r\n    }\r\n}\r\n\r\nexport class Identifier implements IExpression {\r\n    constructor(public token: Token) {}\r\n    toString() {\r\n      return `Identifier(${this.token})`;\r\n    }\r\n}\r\n\r\nexport class BinaryOp implements IExpression {\r\n    constructor(\r\n        public expr1: IExpression,\r\n        public op: Token,\r\n        public expr2: IExpression\r\n    ) {}\r\n\r\n    toString() {\r\n      return `BinOp(${this.expr1} ${this.op} ${this.expr2})`;\r\n    }\r\n}\r\n\r\nexport class ArrayLiteral implements IExpression {\r\n    constructor(public items: IExpression[]) {}\r\n    toString() {\r\n      return `ArrayLit(${this.items.join(\", \")})`;\r\n    }\r\n  }\r\n  \r\n  export class ArrayAccess implements IExpression {\r\n    constructor(public array: Identifier, public index: IExpression) {}\r\n    toString() {\r\n      return `ArrayAccess(${this.array} ${this.index})`;\r\n    }\r\n}", "export type Type = IType & (Prim | ArrayType | Pointer);\r\nexport interface IType {\r\n  toString(): string;\r\n  eq(other: Type): boolean;\r\n}\r\n\r\nexport class ArrayType implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof ArrayType && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}[]`;\r\n  }\r\n}\r\n\r\nexport class Pointer implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof Pointer && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}*`;\r\n  }\r\n}\r\n\r\nexport class Prim implements IType {\r\n  constructor(private name: string) {\r\n\r\n  }\r\n  eq(other: Type): boolean {\r\n    return this === other;\r\n  }\r\n  static UINT = new Prim(\"UINT\");\r\n  static Char = new Prim(\"CHAR\");\r\n  static Bool = new Prim(\"BOOL\");\r\n\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nexport function parseExpression(parser: Parser) {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL3, \r\n        [Kind.COND_E, Kind.COND_GE, Kind.COND_LE, Kind.COND_G, Kind.COND_L]\r\n    );\r\n}\r\n\r\nfunction genericParseBinOp(parser: Parser, func: (parser: Parser) => ast.Expression, kinds: Kind[]): ast.Expression {\r\n    let expr1 = func(parser);\r\n    //xd shoudl work i think\r\n    while (kinds.includes(parser.buf.current.kind)) {\r\n        let op: Token = parser.buf.current;\r\n        parser.buf.next();\r\n        let expr2 = func(parser);\r\n        expr1 = new ast.BinaryOp(expr1, op, expr2);\r\n    }\r\n    return expr1;\r\n}\r\n\r\nfunction parseExprL3(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL2,\r\n        [Kind.PLUS, Kind.MINUS]\r\n    );\r\n}\r\n\r\nfunction parseExprL2(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL1,\r\n        [Kind.MULT, Kind.DIV]\r\n    );\r\n}\r\n\r\nfunction parseExprL1(parser: Parser) : ast.Expression {\r\n    const current: Token = parser.buf.current;\r\n    parser.buf.next();\r\n    switch(current.kind) {\r\n        case Kind.NUMBER: { return new ast.Number(current); }\r\n        case Kind.IDENTIFIER: {\r\n            const identifier: ast.Identifier = new ast.Identifier(current);\r\n            if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n                const expr: ast.Expression = parseExpression(parser); \r\n                parser.buf.expect(Kind.CLOSE_SQUARE);\r\n                return new ast.ArrayAccess(identifier, expr);\r\n            }\r\n            return identifier;\r\n        }\r\n        case Kind.OPEN_SQUARE: {\r\n            const items: ast.Expression[] = [];\r\n            if(parser.buf.next_if(Kind.CLOSE_SQUARE)) {\r\n              return new ast.ArrayLiteral(items);\r\n            }\r\n            items.push(parseExpression(parser));\r\n            while(!parser.buf.current.eq(Kind.CLOSE_SQUARE)) {\r\n                parser.buf.expect(Kind.COMMA);\r\n                items.push(parseExpression(parser));\r\n            }\r\n            parser.buf.next();\r\n            return new ast.ArrayLiteral(items);\r\n        }\r\n        case Kind.OPEN_PARAN: {\r\n            const expr: ast.Expression = parseExpression(parser);\r\n            parser.buf.expect(Kind.CLOSE_PARAN);\r\n            return expr;\r\n        }\r\n        default: {\r\n            parser.err.throw(current, \"Failed to parser ExprL1\")\r\n        }\r\n    }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { ErrorContext } from \"../errors.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport * as Type from \"../type.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseDeclaration(parser: Parser) {\r\n  const typeToken: Token = parser.buf.expect(Kind.VAR_TYPE);\r\n  let iner: Type.Type; \r\n  if(typeToken.value == \"uint\") {\r\n      iner = Type.Prim.UINT;\r\n  }\r\n  else {\r\n    parser.err.throw(typeToken, \"Unknown type\");\r\n      //Generate error here\r\n  }\r\n\r\n  if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n    parser.buf.expect(Kind.CLOSE_SQUARE);\r\n      iner = new Type.ArrayType(iner);\r\n  }\r\n\r\n  const vartype: ast.VarType = new ast.VarType(iner, typeToken);\r\n  const identifier: Token = parser.buf.expect(Kind.IDENTIFIER);\r\n  if (parser.buf.next_if(Kind.EQUAL)) {\r\n      const expr: ast.Expression = parseExpression(parser);\r\n      parser.buf.try_expect(Kind.SEMICOLON);\r\n      return new ast.Declaration(vartype, new ast.Identifier(identifier), expr);\r\n  }\r\n  return new ast.Declaration(vartype, new ast.Identifier(identifier));\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseAssignment(parser: Parser) {\r\n    const identifier: Token = parser.buf.expect(Kind.IDENTIFIER);\r\n    parser.buf.expect(Kind.EQUAL);\r\n    const expr: ast.Expression = parseExpression(parser);\r\n    parser.buf.expect(Kind.SEMICOLON);\r\n    return new ast.Assignment(new ast.Identifier(identifier), expr);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\nimport { parseStatement } from \"./stmtparser.ts\";\r\n\r\nexport function parseBody(parser: Parser) : ast.Body{\r\n    parser.buf.expect(Kind.OPEN_BRACE);\r\n    const content: ast.Statement[] = []\r\n    while (!parser.buf.current.eq(Kind.CLOSE_BRACE)) {\r\n        content.push(parseStatement(parser));\r\n    }\r\n    parser.buf.next();\r\n    return new ast.Body(content);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseIfStatement(parser: Parser) : ast.IfStatement {\r\n    parser.buf.next();\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    const body: ast.Body = parseBody(parser);\r\n    \r\n    if(parser.buf.next_if(Kind.ELSE)) {\r\n        const elseBody: ast.Body = parseBody(parser);\r\n        return new ast.IfStatement(condition, body, elseBody);\r\n    }\r\n    else if(parser.buf.current.eq(Kind.ELIF)) {\r\n        const elsePart: ast.IfStatement = parseIfStatement(parser);\r\n        return new ast.IfStatement(condition, body, elsePart);\r\n    }\r\n    return new ast.IfStatement(condition, body, undefined);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseWhileStatement(parser: Parser) : ast.WhileStatement {\r\n    parser.buf.expect(Kind.WHILE);\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    if(condition instanceof ast.Number || condition instanceof ast.Identifier) {\r\n        const binop: ast.BinaryOp = new ast.BinaryOp(\r\n            condition,\r\n            new Token(Kind.COND_NE, \"!=\", condition.token.line, condition.token.lineno, condition.token.start),\r\n            new Token(Kind.NUMBER, \"0\", condition.token.line, condition.token.lineno, condition.token.start)\r\n        )\r\n    }\r\n    //assert isinstance(condition, ast.BinaryOp)\r\n    const body: ast.Body = parseBody(parser);\r\n    return new ast.WhileStatement(condition, body);\r\n}", "import {Kind} from \"../token.ts\";\r\nimport * as ast from \"../ast.ts\";\r\nimport {Parser} from \"../parser.ts\"\r\nimport {parseDeclaration} from \"./decparser.ts\";\r\nimport {parseAssignment} from \"./assignparser.ts\"\r\nimport {parseBody} from \"./bodyparser.ts\";\r\nimport { parseIfStatement } from \"./ifparser.ts\";\r\nimport { parseWhileStatement } from \"./whileparser.ts\";\r\n\r\n\r\nexport function parseStatement(parser: Parser) : ast.Statement {\r\n    switch (parser.buf.current.kind) {\r\n        case Kind.VAR_TYPE: return parseDeclaration(parser);\r\n        case Kind.IDENTIFIER: return parseAssignment(parser);\r\n        case Kind.IF: return parseIfStatement(parser);\r\n        case Kind.WHILE: return parseWhileStatement(parser);\r\n        case Kind.OPEN_BRACE: return parseBody(parser);\r\n        default: parser.err.throw(parser.buf.current, \"\")\r\n    }\r\n}", "import * as ast from \"./ast.ts\";\r\nimport {Token} from \"./token.ts\";\r\nimport {TokenBuffer} from \"./tokenbuffer.ts\";\r\nimport { ErrorContext } from \"./errors.ts\";\r\n\r\nimport { parseStatement } from \"./parser/stmtparser.ts\";\r\nexport class Parser {\r\n    err: ErrorContext;\r\n    buf: TokenBuffer;\r\n\r\n    constructor() {\r\n        this.err = new ErrorContext();\r\n        this.buf = new TokenBuffer(this.err);\r\n    }\r\n\r\n    parse(tokens: Token[]) : ast.Statement[] {\r\n        const ast_nodes: ast.Statement[] = [];\r\n        this.buf.set(tokens);\r\n        while(!this.buf.done) {\r\n            ast_nodes.push(parseStatement(this));\r\n        }\r\n        return ast_nodes;\r\n\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
