{
  "version": 3,
  "sources": ["../src/token.ts", "../src/lexer.ts"],
  "sourcesContent": ["export const enum Kind {\r\n  VAR_TYPE = \"VAR_TYPE\",\r\n\r\n  IDENTIFIER = \"IDENTIFIER\",\r\n  NUMBER = \"NUMBER\",\r\n  EQUAL = \"EQUAL\",\r\n  PLUS = \"PLUS\",\r\n  MINUS = \"MINUS\",\r\n  MULT = \"MULT\",\r\n  DIV = \"DIV\",\r\n\r\n  MACROCALL = \"MACROCALL\",\r\n\r\n  COMMENT = \"COMMENT\",\r\n\r\n  OPEN_BRACE = \"OPEN_BRACE\",\r\n  CLOSE_BRACE = \"CLOSE_BRACE\",\r\n  IF = \"IF\",\r\n  ELSE = \"ELSE\",\r\n  ELIF = \"ELIF\",\r\n  WHILE = \"WHILE\",\r\n  MACRO = \"MACRO\",\r\n  COND_G = \"COND_G\",\r\n  COND_L = \"COND_L\",\r\n  COND_E = \"COND_E\",\r\n  COND_LE = \"COND_LE\",\r\n  COND_NE = \"COND_NE\",\r\n  COND_GE = \"COND_GE\",\r\n  COMMA = \"COMMA\",\r\n\r\n  OPEN_PARAN = \"OPEN_PARAN\",\r\n  CLOSE_PARAN = \"CLOSE_PARAN\",\r\n\r\n  OPEN_SQUARE = \"OPEN_SQUARE\",\r\n  CLOSE_SQUARE = \"CLOSE_SQUARE\",\r\n\r\n  SEMICOLON = \"SEMICOLON\",\r\n\r\n  NONE = \"NONE\",\r\n}\r\n\r\nexport class Token {\r\n  constructor(\r\n    public kind: Kind,\r\n    public value: string,\r\n    public line: string,\r\n    public lineno: number,\r\n    public start: number,\r\n    public file_name: string,\r\n  ){}\r\n\r\n  eq(kind: Kind): boolean {\r\n    return this.kind == kind;\r\n  }\r\n\r\n  toString(): string {\r\n    return `Token${JSON.stringify(this)}`;\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\n\r\nclass Buffer {\r\n    current!: string\r\n    pos!: number\r\n    done!: boolean\r\n    line!: string\r\n    set(line: string) {\r\n        this.current = line[0]\r\n        this.pos = 0\r\n        this.done = false\r\n        this.line = line\r\n    }\r\n\r\n    next(): string {\r\n        this.pos += 1\r\n        if (this.pos < this.line.length) {\r\n            this.current = this.line[this.pos]\r\n        } else {\r\n            this.done = true\r\n            this.current = '\\0'\r\n        }\r\n        return this.current\r\n    }\r\n}\r\n\r\nconst keywords: Record<string, Kind> = {\r\n    \"uint\": Kind.VAR_TYPE,\r\n    \"char\": Kind.VAR_TYPE,\r\n    \"if\": Kind.IF,\r\n    \"else\": Kind.ELSE,\r\n    \"elif\": Kind.ELIF,\r\n    \"while\": Kind.WHILE,\r\n    \"macro\": Kind.MACRO,\r\n}\r\n\r\nconst symbols : Record<string, Kind> = {\r\n    '=': Kind.EQUAL,\r\n    ';': Kind.SEMICOLON,\r\n    '{': Kind.OPEN_BRACE,\r\n    '}': Kind.CLOSE_BRACE,\r\n    '>': Kind.COND_G,\r\n    '<': Kind.COND_L,\r\n    '+': Kind.PLUS,\r\n    '-': Kind.MINUS,\r\n    '*': Kind.MULT,\r\n    '(': Kind.OPEN_PARAN,\r\n    ')': Kind.CLOSE_PARAN,\r\n    ',': Kind.COMMA,\r\n    '/': Kind.DIV,\r\n    '[': Kind.OPEN_SQUARE,\r\n    ']': Kind.CLOSE_SQUARE,\r\n}\r\n\r\nconst double_symbols: Record<string, Kind> = {\r\n    \"==\": Kind.COND_E,\r\n    \">=\": Kind.COND_GE,\r\n    \"<=\": Kind.COND_LE,\r\n    \"!=\": Kind.COND_NE,\r\n    \"//\": Kind.COMMENT,\r\n}\r\n\r\nexport function lex(lines: string[], file_name = \"<eval>\") : Token[]{\r\n    const tokens: Token[] = []\r\n    const buf: Buffer = new Buffer()\r\n    let lineno = 0;\r\n    for (const line of lines) {\r\n        lineno++;\r\n        buf.set(line);\r\n        while (!buf.done) {\r\n            if (isDigit(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let num: string = buf.current;\r\n                while (isDigit(buf.next())) {\r\n                    num += buf.current;\r\n                }\r\n                tokens.push(\r\n                    new Token(Kind.NUMBER, num, line, lineno, start, file_name)\r\n                );\r\n            }\r\n            else if(isAlpha(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let word: string = buf.current;\r\n                while (isAlpha(buf.next())) {\r\n                    word += buf.current \r\n                }\r\n                let kind: Kind = Kind.IDENTIFIER;\r\n                if (word in keywords) {\r\n                    kind = keywords[word];\r\n                }\r\n                if (buf.current === \"!\") {\r\n                    buf.next();\r\n                    kind = Kind.MACROCALL;\r\n                }\r\n                tokens.push(\r\n                    new Token(kind, word, line, lineno, start, file_name)\r\n                );\r\n            }\r\n            else {\r\n                if (buf.current in symbols) {\r\n                    let current: string = buf.current;\r\n                    let symbol_kind: Kind = symbols[current];\r\n                    buf.next();\r\n                    const double_symbol = buf.current + current;\r\n                    if (double_symbol in double_symbols) {\r\n                        symbol_kind = double_symbols[double_symbol];\r\n                        current = double_symbol;\r\n                        buf.next();\r\n                    }\r\n\r\n                    if (symbol_kind === Kind.COMMENT) {\r\n                        buf.done = true;\r\n                    } else {\r\n                        tokens.push(\r\n                            new Token(symbol_kind, current, line, lineno, buf.pos, file_name)\r\n                        );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    buf.next();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n\r\nfunction isDigit(x: string) {\r\n    return \"0123456789\".includes(x);\r\n}\r\n\r\nfunction isAlpha(x: string) {\r\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(x);\r\n}\r\n\r\nfunction isAlphaNum(x: string) {\r\n    return isDigit(x) || isAlpha(x);\r\n}"],
  "mappings": "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",
  "names": []
}
