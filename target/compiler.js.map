{
  "version": 3,
  "sources": ["../src/token.ts", "../src/lexer.ts", "../src/tokenbuffer.ts", "../src/errors.ts", "../src/ast.ts", "../src/type.ts", "../src/parser/exprparser.ts", "../src/parser/decparser.ts", "../src/parser/assignparser.ts", "../src/parser/bodyparser.ts", "../src/parser/ifparser.ts", "../src/parser/whileparser.ts", "../src/parser/stmtparser.ts", "../src/parser.ts", "../src/typecheck/variable.ts", "../src/typecheck/scope.ts", "../src/typecheck/exprchecker.ts", "../src/typecheck/typechecker.ts", "../src/codegen.ts"],
  "sourcesContent": ["export const enum Kind {\r\n  VAR_TYPE = \"VAR_TYPE\",\r\n\r\n  IDENTIFIER = \"IDENTIFIER\",\r\n  NUMBER = \"NUMBER\",\r\n  EQUAL = \"EQUAL\",\r\n  PLUS = \"PLUS\",\r\n  MINUS = \"MINUS\",\r\n  MULT = \"MULT\",\r\n  DIV = \"DIV\",\r\n\r\n  MACROCALL = \"MACROCALL\",\r\n\r\n  COMMENT = \"COMMENT\",\r\n\r\n  OPEN_BRACE = \"OPEN_BRACE\",\r\n  CLOSE_BRACE = \"CLOSE_BRACE\",\r\n  IF = \"IF\",\r\n  ELSE = \"ELSE\",\r\n  ELIF = \"ELIF\",\r\n  WHILE = \"WHILE\",\r\n  MACRO = \"MACRO\",\r\n  COND_G = \"COND_G\",\r\n  COND_L = \"COND_L\",\r\n  COND_E = \"COND_E\",\r\n  COND_LE = \"COND_LE\",\r\n  COND_NE = \"COND_NE\",\r\n  COND_GE = \"COND_GE\",\r\n  COMMA = \"COMMA\",\r\n\r\n  OPEN_PARAN = \"OPEN_PARAN\",\r\n  CLOSE_PARAN = \"CLOSE_PARAN\",\r\n\r\n  OPEN_SQUARE = \"OPEN_SQUARE\",\r\n  CLOSE_SQUARE = \"CLOSE_SQUARE\",\r\n\r\n  SEMICOLON = \"SEMICOLON\",\r\n\r\n  NONE = \"NONE\",\r\n}\r\n\r\nexport class Token {\r\n  constructor(\r\n    public kind: Kind,\r\n    public value: string,\r\n    public line: string,\r\n    public lineno: number,\r\n    public start: number,\r\n  ){}\r\n\r\n  eq(kind: Kind): boolean {\r\n    return this.kind == kind;\r\n  }\r\n\r\n  toString(): string {\r\n    return `Token(${this.kind} ${this.lineno}:${this.start} ${JSON.stringify(this.value)})`;\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\n\r\nclass Buffer {\r\n    current!: string\r\n    pos!: number\r\n    done!: boolean\r\n    line!: string\r\n    set(line: string) {\r\n        this.current = line[0]\r\n        this.pos = 0\r\n        this.done = false\r\n        this.line = line\r\n    }\r\n\r\n    next(): string {\r\n        this.pos += 1\r\n        if (this.pos < this.line.length) {\r\n            this.current = this.line[this.pos]\r\n        } else {\r\n            this.done = true\r\n            this.current = '\\0'\r\n        }\r\n        return this.current\r\n    }\r\n}\r\n\r\nconst keywords: Record<string, Kind> = {\r\n    \"uint\": Kind.VAR_TYPE,\r\n    \"char\": Kind.VAR_TYPE,\r\n    \"if\": Kind.IF,\r\n    \"else\": Kind.ELSE,\r\n    \"elif\": Kind.ELIF,\r\n    \"while\": Kind.WHILE,\r\n    \"macro\": Kind.MACRO,\r\n}\r\n\r\nconst symbols : Record<string, Kind> = {\r\n    '=': Kind.EQUAL,\r\n    ';': Kind.SEMICOLON,\r\n    '{': Kind.OPEN_BRACE,\r\n    '}': Kind.CLOSE_BRACE,\r\n    '>': Kind.COND_G,\r\n    '<': Kind.COND_L,\r\n    '+': Kind.PLUS,\r\n    '-': Kind.MINUS,\r\n    '*': Kind.MULT,\r\n    '(': Kind.OPEN_PARAN,\r\n    ')': Kind.CLOSE_PARAN,\r\n    ',': Kind.COMMA,\r\n    '/': Kind.DIV,\r\n    '[': Kind.OPEN_SQUARE,\r\n    ']': Kind.CLOSE_SQUARE,\r\n}\r\n\r\nconst double_symbols: Record<string, Kind> = {\r\n    \"==\": Kind.COND_E,\r\n    \">=\": Kind.COND_GE,\r\n    \"<=\": Kind.COND_LE,\r\n    \"!=\": Kind.COND_NE,\r\n    \"//\": Kind.COMMENT,\r\n}\r\n\r\nexport function lex(lines: string[], file_name = \"<eval>\") : Token[]{\r\n    const tokens: Token[] = []\r\n    const buf: Buffer = new Buffer()\r\n    let lineno = 0;\r\n    for (const line of lines) {\r\n        lineno++;\r\n        buf.set(line);\r\n        while (!buf.done) {\r\n            if (isDigit(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let num: string = buf.current;\r\n                while (isDigit(buf.next())) {\r\n                    num += buf.current;\r\n                }\r\n                tokens.push(\r\n                    new Token(Kind.NUMBER, num, line, lineno, start)\r\n                );\r\n            }\r\n            else if(isAlpha(buf.current)) {\r\n                const start: number = buf.pos;\r\n                let word: string = buf.current;\r\n                while (isAlpha(buf.next())) {\r\n                    word += buf.current \r\n                }\r\n                let kind: Kind = Kind.IDENTIFIER;\r\n                if (word in keywords) {\r\n                    kind = keywords[word];\r\n                }\r\n                if (buf.current === \"!\") {\r\n                    buf.next();\r\n                    kind = Kind.MACROCALL;\r\n                }\r\n                tokens.push(\r\n                    new Token(kind, word, line, lineno, start)\r\n                );\r\n            }\r\n            else {\r\n                if (buf.current in symbols) {\r\n                    let current: string = buf.current;\r\n                    let symbol_kind: Kind = symbols[current];\r\n                    buf.next();\r\n                    const double_symbol = buf.current + current;\r\n                    if (double_symbol in double_symbols) {\r\n                        symbol_kind = double_symbols[double_symbol];\r\n                        current = double_symbol;\r\n                        buf.next();\r\n                    }\r\n\r\n                    if (symbol_kind === Kind.COMMENT) {\r\n                        buf.done = true;\r\n                    } else {\r\n                        tokens.push(\r\n                            new Token(symbol_kind, current, line, lineno, buf.pos)\r\n                        );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    buf.next();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n\r\nfunction isDigit(x: string) {\r\n    return \"0123456789\".includes(x);\r\n}\r\n\r\nfunction isAlpha(x: string) {\r\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".includes(x);\r\n}\r\n\r\nfunction isAlphaNum(x: string) {\r\n    return isDigit(x) || isAlpha(x);\r\n}", "import { ErrorContext } from \"./errors.ts\";\r\nimport { Kind, Token } from \"./token.ts\";\r\n\r\nexport class TokenBuffer {\r\n  constructor(private err: ErrorContext) {}\r\n\r\n  private pos!: number;\r\n  private content!: Token[];\r\n  public current!: Token;\r\n  private lastToken!: Token;\r\n  public done!: boolean;\r\n\r\n  set(content: Token[]) {\r\n    this.pos = 0;\r\n    this.done = false;\r\n    this.content = content;\r\n    this.current = this.content[this.pos];\r\n    // Saving last token for better errors so when the buffer\r\n    // is finished we can see the last token it was working on\r\n    this.lastToken = this.content[this.pos];\r\n  }\r\n\r\n  next(): Token {\r\n    this.pos += 1\r\n    if (this.pos < this.content.length) {\r\n      this.current = this.content[this.pos]\r\n      this.lastToken = this.current\r\n    } else { \r\n      this.done = true\r\n      this.current = new Token(\r\n        Kind.NONE, this.lastToken.value,\r\n        this.lastToken.line, this.lastToken.lineno,\r\n        this.lastToken.start\r\n      )\r\n    }\r\n    return this.current\r\n  }\r\n\r\n  next_if(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    }\r\n    return undefined\r\n  }\r\n  try_expect(kind: Kind): undefined | Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.error(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n\r\n  expect(kind: Kind): Token {\r\n    const c = this.current\r\n    if (c.eq(kind)) {\r\n      this.next()\r\n      return c\r\n    } else {\r\n      this.err.throw(\r\n        c,\r\n        \"Expected token kind '\" + kind + \"', got '\" + c.kind + \"'\")\r\n    }\r\n  }\r\n}", "import { Token } from \"./token.ts\";\r\n\r\nconst enum ErrorLevel {\r\n  Info = \"Info\", Warning = \"Warning\", Error = \"Error\"\r\n}\r\n\r\nclass Info {\r\n  constructor(\r\n    public token: undefined | Token,\r\n    public msg: string,\r\n    public level = ErrorLevel.Error\r\n  ) {}\r\n  static msg(msg: string) {\r\n    return new Info(undefined, msg);\r\n  }\r\n  toString(file_name = \"<eval>\"){\r\n    let output = \"\";\r\n    if (this.token) {\r\n      output += `${file_name}:${this.token.lineno}:${this.token.start}: `;\r\n    }\r\n    output += `${this.level}: ${this.msg}\\n`;\r\n    if (this.token) {\r\n      output += `${this.token.line}\\n`;\r\n      output += ' '.repeat(this.token.start) + '^';\r\n    }\r\n\r\n    return output;\r\n  }\r\n}\r\n\r\nexport class ErrorContext {\r\n  infos: Info[] = []\r\n  warnings: Info[] = []\r\n  errors: Info[] = []\r\n\r\n  has_error() {\r\n    return this.errors.length > 0;\r\n  }\r\n\r\n  throw(token: Token, msg: string): never {\r\n    this.print_errors()\r\n    throw new Error(new Info(token, msg).toString())\r\n  }\r\n  throw_msg(msg: string): never {\r\n    this.print_errors();\r\n    throw new Error(new Info(undefined, msg).toString());\r\n  }\r\n\r\n  error(token: Token, msg: string) {\r\n    this.errors.push(new Info(token, msg))\r\n  }\r\n  error_msg(msg: string) {\r\n    this.errors.push(new Info(undefined, msg))\r\n  }\r\n  warn(token: Token, msg: string) {\r\n    this.warnings.push(new Info(token, msg, ErrorLevel.Warning))\r\n  }\r\n  warn_msg(msg: string) {\r\n    this.warnings.push(new Info(undefined, msg, ErrorLevel.Warning))\r\n  }\r\n  info(token: Token, msg: string) {\r\n    this.infos.push(new Info(token, msg, ErrorLevel.Info))\r\n  }\r\n  info_msg(msg: string) {\r\n    this.infos.push(new Info(undefined, msg, ErrorLevel.Info))\r\n  }\r\n  toString() {\r\n    let messages = \"\";\r\n    if (this.errors.length > 0) {\r\n      messages += \"[ERRORS]:\\n\"\r\n    }\r\n    for (const error of this.errors) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    if (this.warnings.length > 0) {\r\n      messages += \"[WARNINGS]:\\n\"\r\n    }\r\n    for (const error of this.warnings) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    if (this.warnings.length > 0) {\r\n      messages += \"[INFO]:\\n\"\r\n    }\r\n    for (const error of this.infos) {\r\n      messages += error.toString() + \"\\n\";\r\n    }\r\n\r\n    return messages\r\n  }\r\n  print_errors() {\r\n    console.error(this.toString());\r\n  }\r\n}", "import {Token, Kind} from \"./token.ts\";\r\nimport { Type } from \"./type.ts\";\r\n\r\nexport interface AstNode {\r\n    readonly start: Token,\r\n}\r\n\r\n//Statements\r\n//=============================================\r\nexport type Statement = Body | IfStatement | WhileStatement\r\n    | MacroDeclaration | MacroCall | Declaration | Assignment;\r\n\r\nexport interface IStatement extends AstNode {}\r\n\r\nexport class Body implements IStatement {\r\n    constructor(private open: Token, public content: Statement[]) {}\r\n\r\n    get start(): Token {\r\n        return this.open;\r\n    }\r\n\r\n    toString() {\r\n      return `Body {\\n${this.content.join(\"\\n\")}\\n}`;\r\n    }\r\n}\r\n\r\nexport class IfStatement implements IStatement {\r\n    constructor(\r\n        public condition: Expression,\r\n        public body: Body,\r\n        public child: Body | IfStatement | undefined\r\n    ) {\r\n    }\r\n    get start(): Token {\r\n        return this.condition.start;\r\n    }\r\n\r\n    toString() {\r\n      return `If(\\n\\t${this.condition} \\n\\t${this.body} else \\n\\t${this.child ?? \"nothing\"})`;\r\n    }\r\n  }\r\n\r\nexport class WhileStatement implements IStatement {\r\n    constructor(public condition: Expression, public body: Body) {}\r\n\r\n    get start(): Token {\r\n        return this.condition.start;\r\n    }\r\n\r\n    toString() {\r\n      return `While(\\n\\t${this.condition} \\n\\t${this.body})`;\r\n    }\r\n  }\r\n  \r\nexport class MacroDeclaration implements IStatement {\r\n    constructor(\r\n        public name: Identifier,\r\n        public args: Expression[],\r\n        public body: Body\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `MacroDecl(${this.name} ${this.args.join(\", \")};\\n${this.body})`;\r\n    }\r\n  }\r\n  \r\nexport class MacroCall implements IStatement {\r\n    constructor(public name: Identifier, public args: IExpression[]) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `MacroCall(${this.name} ${this.args.join(\", \")}})`;\r\n    }\r\n}\r\n\r\nexport class Declaration implements IStatement {\r\n    constructor(\r\n        public vartype: VarType,\r\n        public name: Identifier,\r\n        public expr?: Expression\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.vartype.start;\r\n    }\r\n\r\n    toString() {\r\n      return `Declaration(${this.vartype} ${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class Assignment implements IStatement {\r\n    constructor(public name: Identifier, public expr: Expression) {}\r\n\r\n    get start(): Token {\r\n        return this.name.start;\r\n    }\r\n\r\n    toString() {\r\n      return `Assignment(${this.name} = ${this.expr})`;\r\n    }\r\n}\r\n\r\nexport class VarType {\r\n    constructor(public type: Type, public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `VarType(${this.type} ${this.token})`;\r\n    }\r\n}\r\n\r\n//Expressions\r\n//=============================================\r\nexport type Expression = Number | Identifier | BinaryOp | ArrayLiteral | ArrayAccess;\r\nexport interface IExpression extends AstNode {}\r\n\r\nexport class Number implements IExpression {\r\n    constructor(public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `Number(${this.token})`\r\n    }\r\n}\r\n\r\nexport class Identifier implements IExpression {\r\n    constructor(public token: Token) {}\r\n\r\n    get start(): Token {\r\n        return this.token;\r\n    }\r\n\r\n    toString() {\r\n      return `Identifier(${this.token})`;\r\n    }\r\n}\r\n\r\nexport class BinaryOp implements IExpression {\r\n    constructor(\r\n        public expr1: Expression,\r\n        public op: Token,\r\n        public expr2: Expression\r\n    ) {}\r\n\r\n    get start(): Token {\r\n        return this.expr1.start;\r\n    }\r\n\r\n    toString() {\r\n      return `BinOp(${this.expr1} ${this.op} ${this.expr2})`;\r\n    }\r\n}\r\n\r\nexport class ArrayLiteral implements IExpression {\r\n    constructor(private open: Token, public items: Expression[]) {}\r\n\r\n    get start(): Token {\r\n        return this.open;\r\n    }\r\n\r\n    toString() {\r\n      return `ArrayLit(${this.items.join(\", \")})`;\r\n    }\r\n  }\r\n  \r\nexport class ArrayAccess implements IExpression {\r\n    constructor(public array: Identifier, public index: Expression) {}\r\n\r\n    get start(): Token {\r\n        return this.array.start;\r\n    }\r\n\r\n    toString() {\r\n      return `ArrayAccess(${this.array} ${this.index})`;\r\n    }\r\n}", "\r\nexport type Type = IType & (Prim | ArrayType | Pointer);\r\nexport interface IType {\r\n  toString(): string;\r\n  eq(other: Type): boolean;\r\n}\r\n\r\nexport class ArrayType implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof ArrayType && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}[]`;\r\n  }\r\n}\r\n\r\nexport class Pointer implements IType {\r\n  constructor(public iner: Type){}\r\n  eq(other: Type): boolean {\r\n    return other instanceof Pointer && this.iner.eq(other);\r\n  }\r\n  toString(): string {\r\n      return `${this.iner.toString()}*`;\r\n  }\r\n}\r\n\r\nexport class Prim implements IType {\r\n  constructor(private name: string) {\r\n\r\n  }\r\n  eq(other: Type): boolean {\r\n    return this === other;\r\n  }\r\n  static UINT = new Prim(\"UINT\");\r\n  static Char = new Prim(\"CHAR\");\r\n  static Bool = new Prim(\"BOOL\");\r\n\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nexport function parseExpression(parser: Parser) {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL3, \r\n        [Kind.COND_E, Kind.COND_GE, Kind.COND_LE, Kind.COND_G, Kind.COND_L]\r\n    );\r\n}\r\n\r\nfunction genericParseBinOp(parser: Parser, func: (parser: Parser) => ast.Expression, kinds: Kind[]): ast.Expression {\r\n    let expr1 = func(parser);\r\n    //xd shoudl work i think\r\n    while (kinds.includes(parser.buf.current.kind)) {\r\n        let op: Token = parser.buf.current;\r\n        parser.buf.next();\r\n        let expr2 = func(parser);\r\n        expr1 = new ast.BinaryOp(expr1, op, expr2);\r\n    }\r\n    return expr1;\r\n}\r\n\r\nfunction parseExprL3(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL2,\r\n        [Kind.PLUS, Kind.MINUS]\r\n    );\r\n}\r\n\r\nfunction parseExprL2(parser: Parser) : ast.Expression {\r\n    return genericParseBinOp(\r\n        parser,\r\n        parseExprL1,\r\n        [Kind.MULT, Kind.DIV]\r\n    );\r\n}\r\n\r\nfunction parseExprL1(parser: Parser) : ast.Expression {\r\n    const current: Token = parser.buf.current;\r\n    parser.buf.next();\r\n    switch(current.kind) {\r\n        case Kind.NUMBER: { return new ast.Number(current); }\r\n        case Kind.IDENTIFIER: {\r\n            const identifier: ast.Identifier = new ast.Identifier(current);\r\n            if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n                const expr: ast.Expression = parseExpression(parser); \r\n                parser.buf.expect(Kind.CLOSE_SQUARE);\r\n                return new ast.ArrayAccess(identifier, expr);\r\n            }\r\n            return identifier;\r\n        }\r\n        case Kind.OPEN_SQUARE: {\r\n            const items: ast.Expression[] = [];\r\n            if(parser.buf.next_if(Kind.CLOSE_SQUARE)) {\r\n              return new ast.ArrayLiteral(current, items);\r\n            }\r\n            items.push(parseExpression(parser));\r\n            while(!parser.buf.current.eq(Kind.CLOSE_SQUARE)) {\r\n                parser.buf.expect(Kind.COMMA);\r\n                items.push(parseExpression(parser));\r\n            }\r\n            parser.buf.next();\r\n            return new ast.ArrayLiteral(current, items);\r\n        }\r\n        case Kind.OPEN_PARAN: {\r\n            const expr: ast.Expression = parseExpression(parser);\r\n            parser.buf.expect(Kind.CLOSE_PARAN);\r\n            return expr;\r\n        }\r\n        default: {\r\n            parser.err.throw(current, \"Failed to parser ExprL1\")\r\n        }\r\n    }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { ErrorContext } from \"../errors.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport * as Type from \"../type.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseDeclaration(parser: Parser) {\r\n  const typeToken: Token = parser.buf.expect(Kind.VAR_TYPE);\r\n  let iner: Type.Type; \r\n  if(typeToken.value == \"uint\") {\r\n      iner = Type.Prim.UINT;\r\n  }\r\n  else {\r\n    parser.err.throw(typeToken, \"Unknown type\");\r\n      //Generate error here\r\n  }\r\n\r\n  if(parser.buf.next_if(Kind.OPEN_SQUARE)) {\r\n    parser.buf.expect(Kind.CLOSE_SQUARE);\r\n      iner = new Type.ArrayType(iner);\r\n  }\r\n\r\n  const vartype: ast.VarType = new ast.VarType(iner, typeToken);\r\n  const identifier: Token = parser.buf.expect(Kind.IDENTIFIER);\r\n  if (parser.buf.next_if(Kind.EQUAL)) {\r\n      const expr: ast.Expression = parseExpression(parser);\r\n      parser.buf.try_expect(Kind.SEMICOLON);\r\n      return new ast.Declaration(vartype, new ast.Identifier(identifier), expr);\r\n  }\r\n  return new ast.Declaration(vartype, new ast.Identifier(identifier));\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Token, Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\n\r\nexport function parseAssignment(parser: Parser) {\r\n    const identifier: Token = parser.buf.expect(Kind.IDENTIFIER);\r\n    parser.buf.expect(Kind.EQUAL);\r\n    const expr: ast.Expression = parseExpression(parser);\r\n    parser.buf.expect(Kind.SEMICOLON);\r\n    return new ast.Assignment(new ast.Identifier(identifier), expr);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport {Kind} from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\nimport { parseStatement } from \"./stmtparser.ts\";\r\n\r\nexport function parseBody(parser: Parser) : ast.Body{\r\n    const open = parser.buf.current;\r\n    parser.buf.expect(Kind.OPEN_BRACE);\r\n    const content: ast.Statement[] = []\r\n    while (!parser.buf.current.eq(Kind.CLOSE_BRACE)) {\r\n        content.push(parseStatement(parser));\r\n    }\r\n    parser.buf.next();\r\n    return new ast.Body(open, content);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseIfStatement(parser: Parser) : ast.IfStatement {\r\n    parser.buf.next();\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    const body: ast.Body = parseBody(parser);\r\n    \r\n    if(parser.buf.next_if(Kind.ELSE)) {\r\n        const elseBody: ast.Body = parseBody(parser);\r\n        return new ast.IfStatement(condition, body, elseBody);\r\n    }\r\n    else if(parser.buf.current.eq(Kind.ELIF)) {\r\n        const elsePart: ast.IfStatement = parseIfStatement(parser);\r\n        return new ast.IfStatement(condition, body, elsePart);\r\n    }\r\n    return new ast.IfStatement(condition, body, undefined);\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind, Token } from \"../token.ts\";\r\nimport { Parser } from \"../parser.ts\";\r\n\r\nimport { parseExpression } from \"./exprparser.ts\";\r\nimport { parseBody } from \"./bodyparser.ts\";\r\n\r\nexport function parseWhileStatement(parser: Parser) : ast.WhileStatement {\r\n    parser.buf.expect(Kind.WHILE);\r\n    const condition: ast.Expression = parseExpression(parser);\r\n    // this should probably be done in codegen not here lol\r\n    if(condition instanceof ast.Number || condition instanceof ast.Identifier) {\r\n        const binop: ast.BinaryOp = new ast.BinaryOp(\r\n            condition,\r\n            new Token(Kind.COND_NE, \"!=\", condition.token.line, condition.token.lineno, condition.token.start),\r\n            new ast.Number(new Token(Kind.NUMBER, \"0\", condition.token.line, condition.token.lineno, condition.token.start))\r\n        )\r\n    }\r\n    //assert isinstance(condition, ast.BinaryOp)\r\n    const body: ast.Body = parseBody(parser);\r\n    return new ast.WhileStatement(condition, body);\r\n}", "import {Kind} from \"../token.ts\";\r\nimport * as ast from \"../ast.ts\";\r\nimport {Parser} from \"../parser.ts\"\r\nimport {parseDeclaration} from \"./decparser.ts\";\r\nimport {parseAssignment} from \"./assignparser.ts\"\r\nimport {parseBody} from \"./bodyparser.ts\";\r\nimport { parseIfStatement } from \"./ifparser.ts\";\r\nimport { parseWhileStatement } from \"./whileparser.ts\";\r\n\r\n\r\nexport function parseStatement(parser: Parser) : ast.Statement {\r\n    switch (parser.buf.current.kind) {\r\n        case Kind.VAR_TYPE: return parseDeclaration(parser);\r\n        case Kind.IDENTIFIER: return parseAssignment(parser);\r\n        case Kind.IF: return parseIfStatement(parser);\r\n        case Kind.WHILE: return parseWhileStatement(parser);\r\n        case Kind.OPEN_BRACE: return parseBody(parser);\r\n        default: parser.err.throw(parser.buf.current, \"\")\r\n    }\r\n}", "import * as ast from \"./ast.ts\";\r\nimport {Token} from \"./token.ts\";\r\nimport {TokenBuffer} from \"./tokenbuffer.ts\";\r\nimport { ErrorContext } from \"./errors.ts\";\r\n\r\nimport { parseStatement } from \"./parser/stmtparser.ts\";\r\nexport class Parser {\r\n    err: ErrorContext;\r\n    buf: TokenBuffer;\r\n\r\n    constructor() {\r\n        this.err = new ErrorContext();\r\n        this.buf = new TokenBuffer(this.err);\r\n    }\r\n\r\n    parse(tokens: Token[]) : ast.Statement[] {\r\n        const ast_nodes: ast.Statement[] = [];\r\n        this.buf.set(tokens);\r\n        while(!this.buf.done) {\r\n            ast_nodes.push(parseStatement(this));\r\n        }\r\n        return ast_nodes;\r\n\r\n    }\r\n}", "import { Type } from \"../type.ts\";\r\nimport { Scope } from \"./scope.ts\";\r\n\r\nexport class Variable {\r\n  constructor(public scope: Scope, public type: Type) {\r\n\r\n  }\r\n}", "import { Type } from \"../type.ts\";\r\nimport { Variable } from \"./variable.ts\";\r\n\r\nexport class Scopes {\r\n  top = new Scope();\r\n  put(name: string, type: Type): void | Variable {\r\n    return this.top.put(name, type);\r\n  }\r\n  get(name: string): void | Variable {\r\n    return this.top.get(name);\r\n  }\r\n\r\n  push() {\r\n    this.top = new Scope(this.top);\r\n  }\r\n  pop(): boolean {\r\n    if (this.top.parent === undefined) {\r\n      return false\r\n    }\r\n    this.top = this.top.parent;\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class Scope {\r\n  variables: Record<string, Variable | void> = {}; \r\n  constructor(readonly parent?: Scope) {}\r\n\r\n  put(name: string, type: Type): void | Variable {\r\n    if (this.get(name)) {\r\n      return undefined;\r\n    }\r\n    const variable = new Variable(this, type);\r\n    this.variables[name] = variable;\r\n  }\r\n\r\n  get(name: string): void | Variable {\r\n    return this.variables[name] ?? this.parent?.get(name);\r\n  }\r\n}", "import * as ast from \"../ast.ts\";\r\nimport { Kind } from \"../token.ts\";\r\nimport { ArrayType, Prim, Type } from \"../type.ts\";\r\nimport { TypeChecker } from \"./typechecker.ts\";\r\n\r\nexport function checkExpr(checker: TypeChecker, node: ast.Expression): void | Type {\r\n    if (node instanceof ast.BinaryOp) {\r\n        checkBinaryOp(checker, node);\r\n    } else if (node instanceof ast.Number) {\r\n        return Prim.UINT;\r\n    } else if (node instanceof ast.Identifier) {\r\n        const variable = checker.scopes.get(node.token.value);\r\n        console.log(checker.scopes);\r\n        if (!variable) {\r\n            checker.err.error(node.token, `Variable is undefined`);\r\n            return undefined;\r\n        }\r\n        return variable.type;\r\n    } else if (node instanceof ast.ArrayLiteral) {\r\n        // fixme: infer the type depending on context\r\n        if (node.items.length == 0) {\r\n            checker.err.error(node.start, \"Empty array\");\r\n            return;\r\n        }\r\n        const type = checkExpr(checker, node.items[0]);\r\n        for (let i = 1; i < node.items.length; i++) {\r\n            const other = checkExpr(checker, node.items[i]);\r\n            if (type && other !== type) {\r\n                checker.err.error(node.items[i].start, \"Types should match within an array\");\r\n            }\r\n        }\r\n        if (!type) {\r\n            return;\r\n        }\r\n        return new ArrayType(type);\r\n    } else if (node instanceof ast.ArrayAccess) {\r\n        const array = checkExpr(checker, node.array);\r\n        if (!(array instanceof ArrayType)) {\r\n            checker.err.error(node.array.start, \"Value is not indexable\");\r\n        }\r\n        const index = checkExpr(checker, node.index);\r\n        if (index === Prim.UINT) {\r\n            checker.err.error(node.index.start, \"Index should be a uint\");\r\n        }\r\n        if (array instanceof ArrayType) {\r\n            return array.iner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction checkBinaryOp(checker: TypeChecker, node: ast.BinaryOp): void | Type {\r\n    const left = checkExpr(checker, node.expr1);\r\n    const right = checkExpr(checker, node.expr2);\r\n    if (left === undefined || right === undefined) {\r\n        return;\r\n    }\r\n    if (left !== right) {\r\n        checker.err.error(node.op, \"Type of left and right-hand side do not match\");\r\n        return;\r\n    }\r\n\r\n    switch (node.op.kind) {\r\n        case Kind.COND_E: case Kind.COND_NE:\r\n        case Kind.COND_GE: case Kind.COND_G:\r\n        case Kind.COND_LE: case Kind.COND_L: return Prim.Bool;\r\n\r\n        default: return left;\r\n    }\r\n}", "import { ErrorContext } from \"../errors.ts\";\r\nimport * as ast from \"../ast.ts\";\r\nimport { Prim, Type } from \"../type.ts\";\r\nimport { Scopes } from \"./scope.ts\";\r\nimport { checkExpr } from \"./exprchecker.ts\";\r\n\r\nexport class TypeChecker {\r\n    constructor(public err: ErrorContext) {}\r\n\r\n    types = new Map<ast.AstNode, Type>();\r\n    scopes = new Scopes();\r\n\r\n    popScope() {\r\n        if (!this.scopes.pop()){\r\n            this.err.throw_msg(\"Poped last scope\");\r\n        }\r\n    }\r\n\r\n    check(tree: ast.Statement[]) {\r\n        for (const node of tree) {\r\n            checkStatement(this, node);\r\n        }\r\n    }\r\n}\r\n\r\nfunction checkStatement(checker: TypeChecker, node: ast.Statement) {\r\n    if (node instanceof ast.Body) {\r\n        checkBody(checker, node);\r\n    } else if (node instanceof ast.IfStatement) {\r\n        checkIf(checker, node);\r\n    } else if (node instanceof ast.WhileStatement) {\r\n        checkWhile(checker, node);\r\n    } else if (node instanceof ast.Assignment) {\r\n        checkAssignment(checker, node);\r\n    } else if (node instanceof ast.Declaration) {\r\n        checkDeclaration(checker, node);\r\n    } else if (node instanceof ast.MacroDeclaration) {\r\n        checkMacroDeclaration(checker, node);\r\n    } else if (node instanceof ast.MacroCall) {\r\n        checkMacroCall(checker, node);\r\n    }\r\n}\r\n\r\n\r\nfunction checkBody(checker: TypeChecker, tree: ast.Body) {\r\n    checker.scopes.push();\r\n    for (const statement of tree.content) {\r\n        checkStatement(checker, statement);\r\n    }\r\n    checker.popScope();\r\n}\r\n// TODO: check these\r\nfunction checkIf(checker: TypeChecker, tree: ast.IfStatement) {\r\n    checkExpr(checker, tree.condition);\r\n    checkBody(checker, tree.body);\r\n    if (tree.child) {\r\n        checkStatement(checker, tree.child);\r\n    }\r\n}\r\nfunction checkWhile(checker: TypeChecker, tree: ast.WhileStatement) {\r\n    checkExpr(checker, tree.condition);\r\n    checkStatement(checker, tree.body);\r\n}\r\n\r\nfunction checkAssignment(checker: TypeChecker, tree: ast.Assignment) {\r\n    checkExpr(checker, tree.expr);\r\n}\r\nfunction checkDeclaration(checker: TypeChecker, tree: ast.Declaration) {\r\n    checker.scopes.put(tree.name.token.value, Prim.UINT);\r\n\r\n    if (tree.expr) {\r\n        checkExpr(checker, tree.expr);\r\n    }\r\n}\r\nfunction checkMacroDeclaration(checker: TypeChecker, tree: ast.MacroDeclaration) {\r\n\r\n}\r\nfunction checkMacroCall(checker: TypeChecker, tree: ast.MacroCall) {\r\n\r\n}", "import * as ast from \"./ast.ts\";\r\n\r\nexport class Asm {\r\n    instrs: string[];\r\n    constructor() {\r\n        this.instrs = [];\r\n    }\r\n    toString() {\r\n        return this.instrs.join(\"\\n\");\r\n    }\r\n\r\n    putLI(dest: number, value: number) {\r\n        this.instrs.push(\"IMM R\" + dest + \" \" + value);\r\n    }\r\n    putLOAD(reg: number, addr: number) {\r\n        this.instrs.push(\"LOAD R\" + reg + \" $\" + addr);\r\n    }\r\n    putSTORE(addr: number, reg: number) {\r\n        this.instrs.push(\"STORE $\" + addr + \" R\" + reg);\r\n    }\r\n    putADD(dest: number, srcA: number, srcB: number) {\r\n        this.instrs.push(\"ADD R\" + dest + \" R\" + srcA + \" R\" + srcB);\r\n    }\r\n}\r\n\r\nexport class CodeGeneration {\r\n    asm: Asm\r\n    allocator: Allocator;\r\n    constructor(maxRegisters: number) {\r\n        this.asm = new Asm();\r\n        this.allocator = new Allocator(maxRegisters);\r\n    }\r\n\r\n    gen(astNodes: ast.Statement[]) : Asm {\r\n        for(const astNode of astNodes) {\r\n            this.genStatement(astNode);\r\n        }\r\n        return this.asm;\r\n    }\r\n\r\n    genStatement(statement: ast.Statement) {\r\n        if(statement instanceof ast.Declaration) {\r\n            this.genDeclaration(statement);\r\n        }\r\n        else if(statement instanceof ast.Assignment) {\r\n\r\n        }\r\n        else if(statement instanceof ast.IfStatement) {\r\n\r\n        }\r\n        else if(statement instanceof ast.WhileStatement) {\r\n\r\n        }\r\n        else {\r\n            //No code gen for this statement\r\n            return;\r\n        }\r\n    }\r\n\r\n    genDeclaration(dec: ast.Declaration) {\r\n        const varType: ast.VarType = dec.vartype;\r\n        const varName: string = dec.name.token.value;\r\n        const addr: number = this.allocator.addVariable(varName);\r\n        if(dec.expr) {\r\n            const reg: number = this.genExpression(dec.expr);\r\n            this.asm.putSTORE(addr, reg)\r\n            this.allocator.setFreeRegister(reg);\r\n        }\r\n    }\r\n\r\n    genExpression(expr: ast.Expression) : number{\r\n        if(expr instanceof ast.Number) {\r\n            const reg: number = this.allocator.getFreeRegister();\r\n            this.asm.putLI(reg, parseInt(expr.token.value, 10))\r\n            return reg;\r\n        }\r\n        else if(expr instanceof ast.Identifier) {\r\n            const memAddr: number = this.allocator.addVariable(expr.token.value);\r\n            const reg: number = this.allocator.getFreeRegister();\r\n            this.asm.putLOAD(reg, memAddr);\r\n            return reg;\r\n        }\r\n        else if(expr instanceof ast.BinaryOp) {\r\n            const reg1: number = this.genExpression(expr.expr1);\r\n            const reg2: number = this.genExpression(expr.expr2);\r\n            switch(expr.op.value) {\r\n                case \"+\": {\r\n                    this.asm.putADD(reg1, reg1, reg2);\r\n                    break;\r\n                }\r\n            }\r\n            this.allocator.setFreeRegister(reg2);\r\n            return reg1;\r\n        }\r\n        else {\r\n            //Generate error \r\n            return -1;\r\n        }\r\n    }\r\n}\r\n\r\nclass Allocator {\r\n    varToMemory: Record<string, number>;\r\n    memory: boolean[];\r\n    registers: boolean[];\r\n\r\n    constructor(maxRegisters: number) {\r\n        this.varToMemory = {};\r\n        this.registers = new Array(maxRegisters);\r\n        this.registers.fill(false);\r\n        this.memory = new Array(512);\r\n        this.memory.fill(false);\r\n    }\r\n\r\n    addVariable(varName: string) : number {\r\n        if(varName in this.varToMemory) {\r\n            return this.varToMemory[varName];\r\n        }\r\n        const addr: number = this.getFreeMemory();\r\n        this.varToMemory[varName] = addr;\r\n        return addr;\r\n    }\r\n\r\n    getFreeRegister() : number {\r\n        const addr: number = this.registers.indexOf(false);\r\n        this.registers[addr] = true;\r\n        return addr;\r\n    }\r\n\r\n    getFreeMemory() : number {\r\n        const addr: number = this.memory.indexOf(false);\r\n        this.memory[addr] = true;\r\n        return addr;\r\n    }\r\n\r\n    setFreeRegister(reg: number) {\r\n        this.registers[reg] = false;\r\n    }\r\n\r\n    setFreeMemory(mem: number) {\r\n        this.memory[mem] = false;\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
